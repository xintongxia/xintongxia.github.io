"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPickedEditHandle = getPickedEditHandle;
exports.getIntermediatePosition = getIntermediatePosition;
exports.getEditHandlesForGeometry = getEditHandlesForGeometry;
exports.ModeHandler = void 0;

var _union = _interopRequireDefault(require("@turf/union"));

var _difference = _interopRequireDefault(require("@turf/difference"));

var _intersect = _interopRequireDefault(require("@turf/intersect"));

var _immutableFeatureCollection = require("../immutable-feature-collection.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ModeHandler =
/*#__PURE__*/
function () {
  // TODO: add underscore
  function ModeHandler(featureCollection) {
    _classCallCheck(this, ModeHandler);

    _defineProperty(this, "featureCollection", void 0);

    _defineProperty(this, "_tentativeFeature", void 0);

    _defineProperty(this, "_modeConfig", null);

    _defineProperty(this, "_selectedFeatureIndexes", []);

    _defineProperty(this, "_clickSequence", []);

    _defineProperty(this, "_context", void 0);

    _defineProperty(this, "_layerId", void 0);

    if (featureCollection) {
      this.setFeatureCollection(featureCollection);
    }
  }

  _createClass(ModeHandler, [{
    key: "getFeatureCollection",
    value: function getFeatureCollection() {
      return this.featureCollection.getObject();
    }
  }, {
    key: "getImmutableFeatureCollection",
    value: function getImmutableFeatureCollection() {
      return this.featureCollection;
    }
  }, {
    key: "getSelectedFeature",
    value: function getSelectedFeature() {
      if (this._selectedFeatureIndexes.length === 1) {
        return this.featureCollection.getObject().features[this._selectedFeatureIndexes[0]];
      }

      return null;
    }
  }, {
    key: "getSelectedGeometry",
    value: function getSelectedGeometry() {
      var feature = this.getSelectedFeature();

      if (feature) {
        return feature.geometry;
      }

      return null;
    }
  }, {
    key: "getSelectedFeaturesAsFeatureCollection",
    value: function getSelectedFeaturesAsFeatureCollection() {
      var _this$featureCollecti = this.featureCollection.getObject(),
          features = _this$featureCollecti.features;

      var selectedFeatures = this.getSelectedFeatureIndexes().map(function (selectedIndex) {
        return features[selectedIndex];
      });
      return {
        type: 'FeatureCollection',
        features: selectedFeatures
      };
    }
  }, {
    key: "setFeatureCollection",
    value: function setFeatureCollection(featureCollection) {
      this.featureCollection = new _immutableFeatureCollection.ImmutableFeatureCollection(featureCollection);
    }
  }, {
    key: "getModeConfig",
    value: function getModeConfig() {
      return this._modeConfig;
    }
  }, {
    key: "setModeConfig",
    value: function setModeConfig(modeConfig) {
      if (this._modeConfig === modeConfig) {
        return;
      }

      this._modeConfig = modeConfig;

      this._setTentativeFeature(null);
    }
  }, {
    key: "getSelectedFeatureIndexes",
    value: function getSelectedFeatureIndexes() {
      return this._selectedFeatureIndexes;
    }
  }, {
    key: "setSelectedFeatureIndexes",
    value: function setSelectedFeatureIndexes(indexes) {
      if (this._selectedFeatureIndexes === indexes) {
        return;
      }

      this._selectedFeatureIndexes = indexes;

      this._setTentativeFeature(null);
    }
  }, {
    key: "setDeckGlContext",
    value: function setDeckGlContext(context) {
      this._context = context;
    }
  }, {
    key: "setLayerId",
    value: function setLayerId(layerId) {
      this._layerId = layerId;
    }
  }, {
    key: "getClickSequence",
    value: function getClickSequence() {
      return this._clickSequence;
    }
  }, {
    key: "resetClickSequence",
    value: function resetClickSequence() {
      this._clickSequence = [];
    }
  }, {
    key: "getTentativeFeature",
    value: function getTentativeFeature() {
      return this._tentativeFeature;
    } // TODO: remove the underscore

  }, {
    key: "_setTentativeFeature",
    value: function _setTentativeFeature(tentativeFeature) {
      this._tentativeFeature = tentativeFeature;

      if (!tentativeFeature) {
        // Reset the click sequence
        this._clickSequence = [];
      }
    }
    /**
     * Returns a flat array of positions for the given feature along with their indexes into the feature's geometry's coordinates.
     *
     * @param featureIndex The index of the feature to get edit handles
     */

  }, {
    key: "getEditHandles",
    value: function getEditHandles(picks, groundCoords) {
      return [];
    }
  }, {
    key: "getCursor",
    value: function getCursor(_ref) {
      var isDragging = _ref.isDragging;
      return 'cell';
    }
  }, {
    key: "isSelectionPicked",
    value: function isSelectionPicked(picks) {
      if (!picks.length) return false;
      var pickedIndexes = picks.map(function (_ref2) {
        var index = _ref2.index;
        return index;
      });
      var selectedFeatureIndexes = this.getSelectedFeatureIndexes();
      return selectedFeatureIndexes.some(function (index) {
        return pickedIndexes.includes(index);
      });
    }
  }, {
    key: "getAddFeatureAction",
    value: function getAddFeatureAction(geometry) {
      // Unsure why flow can't deal with Geometry type, but there I fixed it
      var geometryAsAny = geometry;
      var updatedData = this.getImmutableFeatureCollection().addFeature({
        type: 'Feature',
        properties: {},
        geometry: geometryAsAny
      }).getObject();
      return {
        updatedData: updatedData,
        editType: 'addFeature',
        featureIndexes: [updatedData.features.length - 1],
        editContext: null
      };
    }
  }, {
    key: "getAddManyFeaturesAction",
    value: function getAddManyFeaturesAction(featureCollection) {
      var features = featureCollection.features;
      var updatedData = this.getImmutableFeatureCollection();
      var initialIndex = updatedData.getObject().features.length;
      var updatedIndexes = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var feature = _step.value;
          var properties = feature.properties,
              geometry = feature.geometry;
          var geometryAsAny = geometry;
          updatedData = updatedData.addFeature({
            type: 'Feature',
            properties: properties,
            geometry: geometryAsAny
          });
          updatedIndexes.push(initialIndex + updatedIndexes.length);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return {
        updatedData: updatedData.getObject(),
        editType: 'addFeature',
        featureIndexes: updatedIndexes,
        editContext: null
      };
    }
  }, {
    key: "getAddFeatureOrBooleanPolygonAction",
    value: function getAddFeatureOrBooleanPolygonAction(geometry) {
      var selectedFeature = this.getSelectedFeature();
      var modeConfig = this.getModeConfig();

      if (modeConfig && modeConfig.booleanOperation) {
        if (!selectedFeature || selectedFeature.geometry.type !== 'Polygon' && selectedFeature.geometry.type !== 'MultiPolygon') {
          // eslint-disable-next-line no-console,no-undef
          console.warn('booleanOperation only supported for single Polygon or MultiPolygon selection');
          return null;
        }

        var feature = {
          type: 'Feature',
          geometry: geometry
        };
        var updatedGeometry;

        if (modeConfig.booleanOperation === 'union') {
          updatedGeometry = (0, _union.default)(selectedFeature, feature);
        } else if (modeConfig.booleanOperation === 'difference') {
          updatedGeometry = (0, _difference.default)(selectedFeature, feature);
        } else if (modeConfig.booleanOperation === 'intersection') {
          updatedGeometry = (0, _intersect.default)(selectedFeature, feature);
        } else {
          // eslint-disable-next-line no-console,no-undef
          console.warn("Invalid booleanOperation ".concat(modeConfig.booleanOperation));
          return null;
        }

        if (!updatedGeometry) {
          // eslint-disable-next-line no-console,no-undef
          console.warn('Canceling edit. Boolean operation erased entire polygon.');
          return null;
        }

        var featureIndex = this.getSelectedFeatureIndexes()[0];
        var updatedData = this.getImmutableFeatureCollection().replaceGeometry(featureIndex, updatedGeometry.geometry).getObject();
        var editAction = {
          updatedData: updatedData,
          editType: 'unionGeometry',
          featureIndexes: [featureIndex],
          editContext: null
        };
        return editAction;
      }

      return this.getAddFeatureAction(geometry);
    }
  }, {
    key: "handleClick",
    value: function handleClick(event) {
      this._clickSequence.push(event.groundCoords);

      return null;
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event) {
      return {
        editAction: null,
        cancelMapPan: false
      };
    }
  }, {
    key: "handleStartDragging",
    value: function handleStartDragging(event) {
      return null;
    }
  }, {
    key: "handleStopDragging",
    value: function handleStopDragging(event) {
      return null;
    }
  }]);

  return ModeHandler;
}();

exports.ModeHandler = ModeHandler;

function getPickedEditHandle(picks) {
  var info = picks && picks.find(function (pick) {
    return pick.isEditingHandle;
  });

  if (info) {
    return info.object;
  }

  return null;
}

function getIntermediatePosition(position1, position2) {
  var intermediatePosition = [(position1[0] + position2[0]) / 2.0, (position1[1] + position2[1]) / 2.0];
  return intermediatePosition;
}

function getEditHandlesForGeometry(geometry, featureIndex) {
  var editHandleType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'existing';
  var handles = [];

  switch (geometry.type) {
    case 'Point':
      // positions are not nested
      handles = [{
        position: geometry.coordinates,
        positionIndexes: [],
        featureIndex: featureIndex,
        type: editHandleType
      }];
      break;

    case 'MultiPoint':
    case 'LineString':
      // positions are nested 1 level
      handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType));
      break;

    case 'Polygon':
    case 'MultiLineString':
      // positions are nested 2 levels
      for (var a = 0; a < geometry.coordinates.length; a++) {
        handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType));

        if (geometry.type === 'Polygon') {
          // Don't repeat the first/last handle for Polygons
          handles = handles.slice(0, -1);
        }
      }

      break;

    case 'MultiPolygon':
      // positions are nested 3 levels
      for (var _a = 0; _a < geometry.coordinates.length; _a++) {
        for (var b = 0; b < geometry.coordinates[_a].length; b++) {
          handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[_a][b], [_a, b], featureIndex, editHandleType)); // Don't repeat the first/last handle for Polygons

          handles = handles.slice(0, -1);
        }
      }

      break;

    default:
      throw Error("Unhandled geometry type: ".concat(geometry.type));
  }

  return handles;
}

function getEditHandlesForCoordinates(coordinates, positionIndexPrefix, featureIndex) {
  var editHandleType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'existing';
  var editHandles = [];

  for (var i = 0; i < coordinates.length; i++) {
    var position = coordinates[i];
    editHandles.push({
      position: position,
      positionIndexes: _toConsumableArray(positionIndexPrefix).concat([i]),
      featureIndex: featureIndex,
      type: editHandleType
    });
  }

  return editHandles;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlLWhhbmRsZXJzL21vZGUtaGFuZGxlci5qcyJdLCJuYW1lcyI6WyJNb2RlSGFuZGxlciIsImZlYXR1cmVDb2xsZWN0aW9uIiwic2V0RmVhdHVyZUNvbGxlY3Rpb24iLCJnZXRPYmplY3QiLCJfc2VsZWN0ZWRGZWF0dXJlSW5kZXhlcyIsImxlbmd0aCIsImZlYXR1cmVzIiwiZmVhdHVyZSIsImdldFNlbGVjdGVkRmVhdHVyZSIsImdlb21ldHJ5Iiwic2VsZWN0ZWRGZWF0dXJlcyIsImdldFNlbGVjdGVkRmVhdHVyZUluZGV4ZXMiLCJtYXAiLCJzZWxlY3RlZEluZGV4IiwidHlwZSIsIkltbXV0YWJsZUZlYXR1cmVDb2xsZWN0aW9uIiwiX21vZGVDb25maWciLCJtb2RlQ29uZmlnIiwiX3NldFRlbnRhdGl2ZUZlYXR1cmUiLCJpbmRleGVzIiwiY29udGV4dCIsIl9jb250ZXh0IiwibGF5ZXJJZCIsIl9sYXllcklkIiwiX2NsaWNrU2VxdWVuY2UiLCJfdGVudGF0aXZlRmVhdHVyZSIsInRlbnRhdGl2ZUZlYXR1cmUiLCJwaWNrcyIsImdyb3VuZENvb3JkcyIsImlzRHJhZ2dpbmciLCJwaWNrZWRJbmRleGVzIiwiaW5kZXgiLCJzZWxlY3RlZEZlYXR1cmVJbmRleGVzIiwic29tZSIsImluY2x1ZGVzIiwiZ2VvbWV0cnlBc0FueSIsInVwZGF0ZWREYXRhIiwiZ2V0SW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24iLCJhZGRGZWF0dXJlIiwicHJvcGVydGllcyIsImVkaXRUeXBlIiwiZmVhdHVyZUluZGV4ZXMiLCJlZGl0Q29udGV4dCIsImluaXRpYWxJbmRleCIsInVwZGF0ZWRJbmRleGVzIiwicHVzaCIsInNlbGVjdGVkRmVhdHVyZSIsImdldE1vZGVDb25maWciLCJib29sZWFuT3BlcmF0aW9uIiwiY29uc29sZSIsIndhcm4iLCJ1cGRhdGVkR2VvbWV0cnkiLCJmZWF0dXJlSW5kZXgiLCJyZXBsYWNlR2VvbWV0cnkiLCJlZGl0QWN0aW9uIiwiZ2V0QWRkRmVhdHVyZUFjdGlvbiIsImV2ZW50IiwiY2FuY2VsTWFwUGFuIiwiZ2V0UGlja2VkRWRpdEhhbmRsZSIsImluZm8iLCJmaW5kIiwicGljayIsImlzRWRpdGluZ0hhbmRsZSIsIm9iamVjdCIsImdldEludGVybWVkaWF0ZVBvc2l0aW9uIiwicG9zaXRpb24xIiwicG9zaXRpb24yIiwiaW50ZXJtZWRpYXRlUG9zaXRpb24iLCJnZXRFZGl0SGFuZGxlc0Zvckdlb21ldHJ5IiwiZWRpdEhhbmRsZVR5cGUiLCJoYW5kbGVzIiwicG9zaXRpb24iLCJjb29yZGluYXRlcyIsInBvc2l0aW9uSW5kZXhlcyIsImNvbmNhdCIsImdldEVkaXRIYW5kbGVzRm9yQ29vcmRpbmF0ZXMiLCJhIiwic2xpY2UiLCJiIiwiRXJyb3IiLCJwb3NpdGlvbkluZGV4UHJlZml4IiwiZWRpdEhhbmRsZXMiLCJpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBa0JhQSxXOzs7QUFDWDtBQVNBLHVCQUFZQyxpQkFBWixFQUFtRDtBQUFBOztBQUFBOztBQUFBOztBQUFBLHlDQU5oQyxJQU1nQzs7QUFBQSxxREFMZixFQUtlOztBQUFBLDRDQUp0QixFQUlzQjs7QUFBQTs7QUFBQTs7QUFDakQsUUFBSUEsaUJBQUosRUFBdUI7QUFDckIsV0FBS0Msb0JBQUwsQ0FBMEJELGlCQUExQjtBQUNEO0FBQ0Y7Ozs7MkNBRXlDO0FBQ3hDLGFBQU8sS0FBS0EsaUJBQUwsQ0FBdUJFLFNBQXZCLEVBQVA7QUFDRDs7O29EQUUyRDtBQUMxRCxhQUFPLEtBQUtGLGlCQUFaO0FBQ0Q7Ozt5Q0FFOEI7QUFDN0IsVUFBSSxLQUFLRyx1QkFBTCxDQUE2QkMsTUFBN0IsS0FBd0MsQ0FBNUMsRUFBK0M7QUFDN0MsZUFBTyxLQUFLSixpQkFBTCxDQUF1QkUsU0FBdkIsR0FBbUNHLFFBQW5DLENBQTRDLEtBQUtGLHVCQUFMLENBQTZCLENBQTdCLENBQTVDLENBQVA7QUFDRDs7QUFDRCxhQUFPLElBQVA7QUFDRDs7OzBDQUVnQztBQUMvQixVQUFNRyxPQUFPLEdBQUcsS0FBS0Msa0JBQUwsRUFBaEI7O0FBQ0EsVUFBSUQsT0FBSixFQUFhO0FBQ1gsZUFBT0EsT0FBTyxDQUFDRSxRQUFmO0FBQ0Q7O0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7Ozs2REFFMkQ7QUFBQSxrQ0FDckMsS0FBS1IsaUJBQUwsQ0FBdUJFLFNBQXZCLEVBRHFDO0FBQUEsVUFDbERHLFFBRGtELHlCQUNsREEsUUFEa0Q7O0FBRTFELFVBQU1JLGdCQUFnQixHQUFHLEtBQUtDLHlCQUFMLEdBQWlDQyxHQUFqQyxDQUN2QixVQUFBQyxhQUFhO0FBQUEsZUFBSVAsUUFBUSxDQUFDTyxhQUFELENBQVo7QUFBQSxPQURVLENBQXpCO0FBR0EsYUFBTztBQUNMQyxRQUFBQSxJQUFJLEVBQUUsbUJBREQ7QUFFTFIsUUFBQUEsUUFBUSxFQUFFSTtBQUZMLE9BQVA7QUFJRDs7O3lDQUVvQlQsaUIsRUFBNEM7QUFDL0QsV0FBS0EsaUJBQUwsR0FBeUIsSUFBSWMsc0RBQUosQ0FBK0JkLGlCQUEvQixDQUF6QjtBQUNEOzs7b0NBRW9CO0FBQ25CLGFBQU8sS0FBS2UsV0FBWjtBQUNEOzs7a0NBRWFDLFUsRUFBdUI7QUFDbkMsVUFBSSxLQUFLRCxXQUFMLEtBQXFCQyxVQUF6QixFQUFxQztBQUNuQztBQUNEOztBQUVELFdBQUtELFdBQUwsR0FBbUJDLFVBQW5COztBQUNBLFdBQUtDLG9CQUFMLENBQTBCLElBQTFCO0FBQ0Q7OztnREFFcUM7QUFDcEMsYUFBTyxLQUFLZCx1QkFBWjtBQUNEOzs7OENBRXlCZSxPLEVBQXlCO0FBQ2pELFVBQUksS0FBS2YsdUJBQUwsS0FBaUNlLE9BQXJDLEVBQThDO0FBQzVDO0FBQ0Q7O0FBRUQsV0FBS2YsdUJBQUwsR0FBK0JlLE9BQS9COztBQUNBLFdBQUtELG9CQUFMLENBQTBCLElBQTFCO0FBQ0Q7OztxQ0FFZ0JFLE8sRUFBaUI7QUFDaEMsV0FBS0MsUUFBTCxHQUFnQkQsT0FBaEI7QUFDRDs7OytCQUVVRSxPLEVBQWlCO0FBQzFCLFdBQUtDLFFBQUwsR0FBZ0JELE9BQWhCO0FBQ0Q7Ozt1Q0FFOEI7QUFDN0IsYUFBTyxLQUFLRSxjQUFaO0FBQ0Q7Ozt5Q0FFMEI7QUFDekIsV0FBS0EsY0FBTCxHQUFzQixFQUF0QjtBQUNEOzs7MENBRStCO0FBQzlCLGFBQU8sS0FBS0MsaUJBQVo7QUFDRCxLLENBRUQ7Ozs7eUNBQ3FCQyxnQixFQUFrQztBQUNyRCxXQUFLRCxpQkFBTCxHQUF5QkMsZ0JBQXpCOztBQUNBLFVBQUksQ0FBQ0EsZ0JBQUwsRUFBdUI7QUFDckI7QUFDQSxhQUFLRixjQUFMLEdBQXNCLEVBQXRCO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7OzttQ0FLZUcsSyxFQUF1QkMsWSxFQUF1QztBQUMzRSxhQUFPLEVBQVA7QUFDRDs7O29DQUUwRDtBQUFBLFVBQS9DQyxVQUErQyxRQUEvQ0EsVUFBK0M7QUFDekQsYUFBTyxNQUFQO0FBQ0Q7OztzQ0FFaUJGLEssRUFBOEI7QUFDOUMsVUFBSSxDQUFDQSxLQUFLLENBQUN0QixNQUFYLEVBQW1CLE9BQU8sS0FBUDtBQUNuQixVQUFNeUIsYUFBYSxHQUFHSCxLQUFLLENBQUNmLEdBQU4sQ0FBVTtBQUFBLFlBQUdtQixLQUFILFNBQUdBLEtBQUg7QUFBQSxlQUFlQSxLQUFmO0FBQUEsT0FBVixDQUF0QjtBQUNBLFVBQU1DLHNCQUFzQixHQUFHLEtBQUtyQix5QkFBTCxFQUEvQjtBQUNBLGFBQU9xQixzQkFBc0IsQ0FBQ0MsSUFBdkIsQ0FBNEIsVUFBQUYsS0FBSztBQUFBLGVBQUlELGFBQWEsQ0FBQ0ksUUFBZCxDQUF1QkgsS0FBdkIsQ0FBSjtBQUFBLE9BQWpDLENBQVA7QUFDRDs7O3dDQUVtQnRCLFEsRUFBZ0M7QUFDbEQ7QUFDQSxVQUFNMEIsYUFBa0IsR0FBRzFCLFFBQTNCO0FBRUEsVUFBTTJCLFdBQVcsR0FBRyxLQUFLQyw2QkFBTCxHQUNqQkMsVUFEaUIsQ0FDTjtBQUNWeEIsUUFBQUEsSUFBSSxFQUFFLFNBREk7QUFFVnlCLFFBQUFBLFVBQVUsRUFBRSxFQUZGO0FBR1Y5QixRQUFBQSxRQUFRLEVBQUUwQjtBQUhBLE9BRE0sRUFNakJoQyxTQU5pQixFQUFwQjtBQVFBLGFBQU87QUFDTGlDLFFBQUFBLFdBQVcsRUFBWEEsV0FESztBQUVMSSxRQUFBQSxRQUFRLEVBQUUsWUFGTDtBQUdMQyxRQUFBQSxjQUFjLEVBQUUsQ0FBQ0wsV0FBVyxDQUFDOUIsUUFBWixDQUFxQkQsTUFBckIsR0FBOEIsQ0FBL0IsQ0FIWDtBQUlMcUMsUUFBQUEsV0FBVyxFQUFFO0FBSlIsT0FBUDtBQU1EOzs7NkNBRXdCekMsaUIsRUFBa0Q7QUFDekUsVUFBTUssUUFBUSxHQUFHTCxpQkFBaUIsQ0FBQ0ssUUFBbkM7QUFDQSxVQUFJOEIsV0FBVyxHQUFHLEtBQUtDLDZCQUFMLEVBQWxCO0FBQ0EsVUFBTU0sWUFBWSxHQUFHUCxXQUFXLENBQUNqQyxTQUFaLEdBQXdCRyxRQUF4QixDQUFpQ0QsTUFBdEQ7QUFDQSxVQUFNdUMsY0FBYyxHQUFHLEVBQXZCO0FBSnlFO0FBQUE7QUFBQTs7QUFBQTtBQUt6RSw2QkFBc0J0QyxRQUF0Qiw4SEFBZ0M7QUFBQSxjQUFyQkMsT0FBcUI7QUFBQSxjQUN0QmdDLFVBRHNCLEdBQ0doQyxPQURILENBQ3RCZ0MsVUFEc0I7QUFBQSxjQUNWOUIsUUFEVSxHQUNHRixPQURILENBQ1ZFLFFBRFU7QUFFOUIsY0FBTTBCLGFBQWtCLEdBQUcxQixRQUEzQjtBQUNBMkIsVUFBQUEsV0FBVyxHQUFHQSxXQUFXLENBQUNFLFVBQVosQ0FBdUI7QUFDbkN4QixZQUFBQSxJQUFJLEVBQUUsU0FENkI7QUFFbkN5QixZQUFBQSxVQUFVLEVBQVZBLFVBRm1DO0FBR25DOUIsWUFBQUEsUUFBUSxFQUFFMEI7QUFIeUIsV0FBdkIsQ0FBZDtBQUtBUyxVQUFBQSxjQUFjLENBQUNDLElBQWYsQ0FBb0JGLFlBQVksR0FBR0MsY0FBYyxDQUFDdkMsTUFBbEQ7QUFDRDtBQWR3RTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWdCekUsYUFBTztBQUNMK0IsUUFBQUEsV0FBVyxFQUFFQSxXQUFXLENBQUNqQyxTQUFaLEVBRFI7QUFFTHFDLFFBQUFBLFFBQVEsRUFBRSxZQUZMO0FBR0xDLFFBQUFBLGNBQWMsRUFBRUcsY0FIWDtBQUlMRixRQUFBQSxXQUFXLEVBQUU7QUFKUixPQUFQO0FBTUQ7Ozt3REFFbUNqQyxRLEVBQWdDO0FBQ2xFLFVBQU1xQyxlQUFlLEdBQUcsS0FBS3RDLGtCQUFMLEVBQXhCO0FBQ0EsVUFBTVMsVUFBVSxHQUFHLEtBQUs4QixhQUFMLEVBQW5COztBQUNBLFVBQUk5QixVQUFVLElBQUlBLFVBQVUsQ0FBQytCLGdCQUE3QixFQUErQztBQUM3QyxZQUNFLENBQUNGLGVBQUQsSUFDQ0EsZUFBZSxDQUFDckMsUUFBaEIsQ0FBeUJLLElBQXpCLEtBQWtDLFNBQWxDLElBQ0NnQyxlQUFlLENBQUNyQyxRQUFoQixDQUF5QkssSUFBekIsS0FBa0MsY0FIdEMsRUFJRTtBQUNBO0FBQ0FtQyxVQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FDRSw4RUFERjtBQUdBLGlCQUFPLElBQVA7QUFDRDs7QUFFRCxZQUFNM0MsT0FBTyxHQUFHO0FBQ2RPLFVBQUFBLElBQUksRUFBRSxTQURRO0FBRWRMLFVBQUFBLFFBQVEsRUFBUkE7QUFGYyxTQUFoQjtBQUtBLFlBQUkwQyxlQUFKOztBQUNBLFlBQUlsQyxVQUFVLENBQUMrQixnQkFBWCxLQUFnQyxPQUFwQyxFQUE2QztBQUMzQ0csVUFBQUEsZUFBZSxHQUFHLG9CQUFVTCxlQUFWLEVBQTJCdkMsT0FBM0IsQ0FBbEI7QUFDRCxTQUZELE1BRU8sSUFBSVUsVUFBVSxDQUFDK0IsZ0JBQVgsS0FBZ0MsWUFBcEMsRUFBa0Q7QUFDdkRHLFVBQUFBLGVBQWUsR0FBRyx5QkFBZUwsZUFBZixFQUFnQ3ZDLE9BQWhDLENBQWxCO0FBQ0QsU0FGTSxNQUVBLElBQUlVLFVBQVUsQ0FBQytCLGdCQUFYLEtBQWdDLGNBQXBDLEVBQW9EO0FBQ3pERyxVQUFBQSxlQUFlLEdBQUcsd0JBQWNMLGVBQWQsRUFBK0J2QyxPQUEvQixDQUFsQjtBQUNELFNBRk0sTUFFQTtBQUNMO0FBQ0EwQyxVQUFBQSxPQUFPLENBQUNDLElBQVIsb0NBQXlDakMsVUFBVSxDQUFDK0IsZ0JBQXBEO0FBQ0EsaUJBQU8sSUFBUDtBQUNEOztBQUVELFlBQUksQ0FBQ0csZUFBTCxFQUFzQjtBQUNwQjtBQUNBRixVQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSwwREFBYjtBQUNBLGlCQUFPLElBQVA7QUFDRDs7QUFFRCxZQUFNRSxZQUFZLEdBQUcsS0FBS3pDLHlCQUFMLEdBQWlDLENBQWpDLENBQXJCO0FBRUEsWUFBTXlCLFdBQVcsR0FBRyxLQUFLQyw2QkFBTCxHQUNqQmdCLGVBRGlCLENBQ0RELFlBREMsRUFDYUQsZUFBZSxDQUFDMUMsUUFEN0IsRUFFakJOLFNBRmlCLEVBQXBCO0FBSUEsWUFBTW1ELFVBQXNCLEdBQUc7QUFDN0JsQixVQUFBQSxXQUFXLEVBQVhBLFdBRDZCO0FBRTdCSSxVQUFBQSxRQUFRLEVBQUUsZUFGbUI7QUFHN0JDLFVBQUFBLGNBQWMsRUFBRSxDQUFDVyxZQUFELENBSGE7QUFJN0JWLFVBQUFBLFdBQVcsRUFBRTtBQUpnQixTQUEvQjtBQU9BLGVBQU9ZLFVBQVA7QUFDRDs7QUFDRCxhQUFPLEtBQUtDLG1CQUFMLENBQXlCOUMsUUFBekIsQ0FBUDtBQUNEOzs7Z0NBRVcrQyxLLEVBQWdDO0FBQzFDLFdBQUtoQyxjQUFMLENBQW9CcUIsSUFBcEIsQ0FBeUJXLEtBQUssQ0FBQzVCLFlBQS9COztBQUVBLGFBQU8sSUFBUDtBQUNEOzs7c0NBRWlCNEIsSyxFQUE2RTtBQUM3RixhQUFPO0FBQUVGLFFBQUFBLFVBQVUsRUFBRSxJQUFkO0FBQW9CRyxRQUFBQSxZQUFZLEVBQUU7QUFBbEMsT0FBUDtBQUNEOzs7d0NBRW1CRCxLLEVBQXdDO0FBQzFELGFBQU8sSUFBUDtBQUNEOzs7dUNBRWtCQSxLLEVBQXVDO0FBQ3hELGFBQU8sSUFBUDtBQUNEOzs7Ozs7OztBQUdJLFNBQVNFLG1CQUFULENBQTZCL0IsS0FBN0IsRUFBMkQ7QUFDaEUsTUFBTWdDLElBQUksR0FBR2hDLEtBQUssSUFBSUEsS0FBSyxDQUFDaUMsSUFBTixDQUFXLFVBQUFDLElBQUk7QUFBQSxXQUFJQSxJQUFJLENBQUNDLGVBQVQ7QUFBQSxHQUFmLENBQXRCOztBQUNBLE1BQUlILElBQUosRUFBVTtBQUNSLFdBQU9BLElBQUksQ0FBQ0ksTUFBWjtBQUNEOztBQUNELFNBQU8sSUFBUDtBQUNEOztBQUVNLFNBQVNDLHVCQUFULENBQWlDQyxTQUFqQyxFQUFzREMsU0FBdEQsRUFBcUY7QUFDMUYsTUFBTUMsb0JBQW9CLEdBQUcsQ0FDM0IsQ0FBQ0YsU0FBUyxDQUFDLENBQUQsQ0FBVCxHQUFlQyxTQUFTLENBQUMsQ0FBRCxDQUF6QixJQUFnQyxHQURMLEVBRTNCLENBQUNELFNBQVMsQ0FBQyxDQUFELENBQVQsR0FBZUMsU0FBUyxDQUFDLENBQUQsQ0FBekIsSUFBZ0MsR0FGTCxDQUE3QjtBQUlBLFNBQU9DLG9CQUFQO0FBQ0Q7O0FBRU0sU0FBU0MseUJBQVQsQ0FDTDNELFFBREssRUFFTDJDLFlBRkssRUFJTDtBQUFBLE1BREFpQixjQUNBLHVFQURpQyxVQUNqQztBQUNBLE1BQUlDLE9BQXFCLEdBQUcsRUFBNUI7O0FBRUEsVUFBUTdELFFBQVEsQ0FBQ0ssSUFBakI7QUFDRSxTQUFLLE9BQUw7QUFDRTtBQUNBd0QsTUFBQUEsT0FBTyxHQUFHLENBQ1I7QUFDRUMsUUFBQUEsUUFBUSxFQUFFOUQsUUFBUSxDQUFDK0QsV0FEckI7QUFFRUMsUUFBQUEsZUFBZSxFQUFFLEVBRm5CO0FBR0VyQixRQUFBQSxZQUFZLEVBQVpBLFlBSEY7QUFJRXRDLFFBQUFBLElBQUksRUFBRXVEO0FBSlIsT0FEUSxDQUFWO0FBUUE7O0FBQ0YsU0FBSyxZQUFMO0FBQ0EsU0FBSyxZQUFMO0FBQ0U7QUFDQUMsTUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQUNJLE1BQVIsQ0FDUkMsNEJBQTRCLENBQUNsRSxRQUFRLENBQUMrRCxXQUFWLEVBQXVCLEVBQXZCLEVBQTJCcEIsWUFBM0IsRUFBeUNpQixjQUF6QyxDQURwQixDQUFWO0FBR0E7O0FBQ0YsU0FBSyxTQUFMO0FBQ0EsU0FBSyxpQkFBTDtBQUNFO0FBQ0EsV0FBSyxJQUFJTyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbkUsUUFBUSxDQUFDK0QsV0FBVCxDQUFxQm5FLE1BQXpDLEVBQWlEdUUsQ0FBQyxFQUFsRCxFQUFzRDtBQUNwRE4sUUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQUNJLE1BQVIsQ0FDUkMsNEJBQTRCLENBQUNsRSxRQUFRLENBQUMrRCxXQUFULENBQXFCSSxDQUFyQixDQUFELEVBQTBCLENBQUNBLENBQUQsQ0FBMUIsRUFBK0J4QixZQUEvQixFQUE2Q2lCLGNBQTdDLENBRHBCLENBQVY7O0FBR0EsWUFBSTVELFFBQVEsQ0FBQ0ssSUFBVCxLQUFrQixTQUF0QixFQUFpQztBQUMvQjtBQUNBd0QsVUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQUNPLEtBQVIsQ0FBYyxDQUFkLEVBQWlCLENBQUMsQ0FBbEIsQ0FBVjtBQUNEO0FBQ0Y7O0FBQ0Q7O0FBQ0YsU0FBSyxjQUFMO0FBQ0U7QUFDQSxXQUFLLElBQUlELEVBQUMsR0FBRyxDQUFiLEVBQWdCQSxFQUFDLEdBQUduRSxRQUFRLENBQUMrRCxXQUFULENBQXFCbkUsTUFBekMsRUFBaUR1RSxFQUFDLEVBQWxELEVBQXNEO0FBQ3BELGFBQUssSUFBSUUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3JFLFFBQVEsQ0FBQytELFdBQVQsQ0FBcUJJLEVBQXJCLEVBQXdCdkUsTUFBNUMsRUFBb0R5RSxDQUFDLEVBQXJELEVBQXlEO0FBQ3ZEUixVQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0ksTUFBUixDQUNSQyw0QkFBNEIsQ0FDMUJsRSxRQUFRLENBQUMrRCxXQUFULENBQXFCSSxFQUFyQixFQUF3QkUsQ0FBeEIsQ0FEMEIsRUFFMUIsQ0FBQ0YsRUFBRCxFQUFJRSxDQUFKLENBRjBCLEVBRzFCMUIsWUFIMEIsRUFJMUJpQixjQUowQixDQURwQixDQUFWLENBRHVELENBU3ZEOztBQUNBQyxVQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ08sS0FBUixDQUFjLENBQWQsRUFBaUIsQ0FBQyxDQUFsQixDQUFWO0FBQ0Q7QUFDRjs7QUFDRDs7QUFDRjtBQUNFLFlBQU1FLEtBQUssb0NBQTZCdEUsUUFBUSxDQUFDSyxJQUF0QyxFQUFYO0FBbERKOztBQXFEQSxTQUFPd0QsT0FBUDtBQUNEOztBQUVELFNBQVNLLDRCQUFULENBQ0VILFdBREYsRUFFRVEsbUJBRkYsRUFHRTVCLFlBSEYsRUFLZ0I7QUFBQSxNQURkaUIsY0FDYyx1RUFEbUIsVUFDbkI7QUFDZCxNQUFNWSxXQUFXLEdBQUcsRUFBcEI7O0FBQ0EsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHVixXQUFXLENBQUNuRSxNQUFoQyxFQUF3QzZFLENBQUMsRUFBekMsRUFBNkM7QUFDM0MsUUFBTVgsUUFBUSxHQUFHQyxXQUFXLENBQUNVLENBQUQsQ0FBNUI7QUFDQUQsSUFBQUEsV0FBVyxDQUFDcEMsSUFBWixDQUFpQjtBQUNmMEIsTUFBQUEsUUFBUSxFQUFSQSxRQURlO0FBRWZFLE1BQUFBLGVBQWUscUJBQU1PLG1CQUFOLFVBQTJCRSxDQUEzQixFQUZBO0FBR2Y5QixNQUFBQSxZQUFZLEVBQVpBLFlBSGU7QUFJZnRDLE1BQUFBLElBQUksRUFBRXVEO0FBSlMsS0FBakI7QUFNRDs7QUFDRCxTQUFPWSxXQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgdHVyZlVuaW9uIGZyb20gJ0B0dXJmL3VuaW9uJztcbmltcG9ydCB0dXJmRGlmZmVyZW5jZSBmcm9tICdAdHVyZi9kaWZmZXJlbmNlJztcbmltcG9ydCB0dXJmSW50ZXJzZWN0IGZyb20gJ0B0dXJmL2ludGVyc2VjdCc7XG5cbmltcG9ydCB0eXBlIHsgRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmUsIFBvbHlnb24sIEdlb21ldHJ5LCBQb3NpdGlvbiB9IGZyb20gJy4uL2dlb2pzb24tdHlwZXMuanMnO1xuaW1wb3J0IHR5cGUge1xuICBDbGlja0V2ZW50LFxuICBQb2ludGVyTW92ZUV2ZW50LFxuICBTdGFydERyYWdnaW5nRXZlbnQsXG4gIFN0b3BEcmFnZ2luZ0V2ZW50LFxuICBEZWNrR0xQaWNrXG59IGZyb20gJy4uL2V2ZW50LXR5cGVzLmpzJztcbmltcG9ydCB7IEltbXV0YWJsZUZlYXR1cmVDb2xsZWN0aW9uIH0gZnJvbSAnLi4vaW1tdXRhYmxlLWZlYXR1cmUtY29sbGVjdGlvbi5qcyc7XG5cbmV4cG9ydCB0eXBlIEVkaXRIYW5kbGVUeXBlID0gJ2V4aXN0aW5nJyB8ICdpbnRlcm1lZGlhdGUnIHwgJ3NuYXAnO1xuXG5leHBvcnQgdHlwZSBFZGl0SGFuZGxlID0ge1xuICBwb3NpdGlvbjogUG9zaXRpb24sXG4gIHBvc2l0aW9uSW5kZXhlczogbnVtYmVyW10sXG4gIGZlYXR1cmVJbmRleDogbnVtYmVyLFxuICB0eXBlOiBFZGl0SGFuZGxlVHlwZVxufTtcblxuZXhwb3J0IHR5cGUgRWRpdEFjdGlvbiA9IHtcbiAgdXBkYXRlZERhdGE6IEZlYXR1cmVDb2xsZWN0aW9uLFxuICBlZGl0VHlwZTogc3RyaW5nLFxuICBmZWF0dXJlSW5kZXhlczogbnVtYmVyW10sXG4gIGVkaXRDb250ZXh0OiBhbnlcbn07XG5cbmV4cG9ydCBjbGFzcyBNb2RlSGFuZGxlciB7XG4gIC8vIFRPRE86IGFkZCB1bmRlcnNjb3JlXG4gIGZlYXR1cmVDb2xsZWN0aW9uOiBJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbjtcbiAgX3RlbnRhdGl2ZUZlYXR1cmU6ID9GZWF0dXJlO1xuICBfbW9kZUNvbmZpZzogYW55ID0gbnVsbDtcbiAgX3NlbGVjdGVkRmVhdHVyZUluZGV4ZXM6IG51bWJlcltdID0gW107XG4gIF9jbGlja1NlcXVlbmNlOiBQb3NpdGlvbltdID0gW107XG4gIF9jb250ZXh0OiBPYmplY3Q7XG4gIF9sYXllcklkOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoZmVhdHVyZUNvbGxlY3Rpb24/OiBGZWF0dXJlQ29sbGVjdGlvbikge1xuICAgIGlmIChmZWF0dXJlQ29sbGVjdGlvbikge1xuICAgICAgdGhpcy5zZXRGZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlQ29sbGVjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZ2V0RmVhdHVyZUNvbGxlY3Rpb24oKTogRmVhdHVyZUNvbGxlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVDb2xsZWN0aW9uLmdldE9iamVjdCgpO1xuICB9XG5cbiAgZ2V0SW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24oKTogSW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVDb2xsZWN0aW9uO1xuICB9XG5cbiAgZ2V0U2VsZWN0ZWRGZWF0dXJlKCk6ID9GZWF0dXJlIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0ZWRGZWF0dXJlSW5kZXhlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVDb2xsZWN0aW9uLmdldE9iamVjdCgpLmZlYXR1cmVzW3RoaXMuX3NlbGVjdGVkRmVhdHVyZUluZGV4ZXNbMF1dO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFNlbGVjdGVkR2VvbWV0cnkoKTogP0dlb21ldHJ5IHtcbiAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmUoKTtcbiAgICBpZiAoZmVhdHVyZSkge1xuICAgICAgcmV0dXJuIGZlYXR1cmUuZ2VvbWV0cnk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0U2VsZWN0ZWRGZWF0dXJlc0FzRmVhdHVyZUNvbGxlY3Rpb24oKTogRmVhdHVyZUNvbGxlY3Rpb24ge1xuICAgIGNvbnN0IHsgZmVhdHVyZXMgfSA9IHRoaXMuZmVhdHVyZUNvbGxlY3Rpb24uZ2V0T2JqZWN0KCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlcyA9IHRoaXMuZ2V0U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcygpLm1hcChcbiAgICAgIHNlbGVjdGVkSW5kZXggPT4gZmVhdHVyZXNbc2VsZWN0ZWRJbmRleF1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgZmVhdHVyZXM6IHNlbGVjdGVkRmVhdHVyZXNcbiAgICB9O1xuICB9XG5cbiAgc2V0RmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZUNvbGxlY3Rpb246IEZlYXR1cmVDb2xsZWN0aW9uKTogdm9pZCB7XG4gICAgdGhpcy5mZWF0dXJlQ29sbGVjdGlvbiA9IG5ldyBJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlQ29sbGVjdGlvbik7XG4gIH1cblxuICBnZXRNb2RlQ29uZmlnKCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVDb25maWc7XG4gIH1cblxuICBzZXRNb2RlQ29uZmlnKG1vZGVDb25maWc6IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9tb2RlQ29uZmlnID09PSBtb2RlQ29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbW9kZUNvbmZpZyA9IG1vZGVDb25maWc7XG4gICAgdGhpcy5fc2V0VGVudGF0aXZlRmVhdHVyZShudWxsKTtcbiAgfVxuXG4gIGdldFNlbGVjdGVkRmVhdHVyZUluZGV4ZXMoKTogbnVtYmVyW10ge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZEZlYXR1cmVJbmRleGVzO1xuICB9XG5cbiAgc2V0U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcyhpbmRleGVzOiBudW1iZXJbXSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9zZWxlY3RlZEZlYXR1cmVJbmRleGVzID09PSBpbmRleGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc2VsZWN0ZWRGZWF0dXJlSW5kZXhlcyA9IGluZGV4ZXM7XG4gICAgdGhpcy5fc2V0VGVudGF0aXZlRmVhdHVyZShudWxsKTtcbiAgfVxuXG4gIHNldERlY2tHbENvbnRleHQoY29udGV4dDogT2JqZWN0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICBzZXRMYXllcklkKGxheWVySWQ6IHN0cmluZykge1xuICAgIHRoaXMuX2xheWVySWQgPSBsYXllcklkO1xuICB9XG5cbiAgZ2V0Q2xpY2tTZXF1ZW5jZSgpOiBQb3NpdGlvbltdIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpY2tTZXF1ZW5jZTtcbiAgfVxuXG4gIHJlc2V0Q2xpY2tTZXF1ZW5jZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9jbGlja1NlcXVlbmNlID0gW107XG4gIH1cblxuICBnZXRUZW50YXRpdmVGZWF0dXJlKCk6ID9GZWF0dXJlIHtcbiAgICByZXR1cm4gdGhpcy5fdGVudGF0aXZlRmVhdHVyZTtcbiAgfVxuXG4gIC8vIFRPRE86IHJlbW92ZSB0aGUgdW5kZXJzY29yZVxuICBfc2V0VGVudGF0aXZlRmVhdHVyZSh0ZW50YXRpdmVGZWF0dXJlOiA/RmVhdHVyZSk6IHZvaWQge1xuICAgIHRoaXMuX3RlbnRhdGl2ZUZlYXR1cmUgPSB0ZW50YXRpdmVGZWF0dXJlO1xuICAgIGlmICghdGVudGF0aXZlRmVhdHVyZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIGNsaWNrIHNlcXVlbmNlXG4gICAgICB0aGlzLl9jbGlja1NlcXVlbmNlID0gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmbGF0IGFycmF5IG9mIHBvc2l0aW9ucyBmb3IgdGhlIGdpdmVuIGZlYXR1cmUgYWxvbmcgd2l0aCB0aGVpciBpbmRleGVzIGludG8gdGhlIGZlYXR1cmUncyBnZW9tZXRyeSdzIGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBAcGFyYW0gZmVhdHVyZUluZGV4IFRoZSBpbmRleCBvZiB0aGUgZmVhdHVyZSB0byBnZXQgZWRpdCBoYW5kbGVzXG4gICAqL1xuICBnZXRFZGl0SGFuZGxlcyhwaWNrcz86IEFycmF5PE9iamVjdD4sIGdyb3VuZENvb3Jkcz86IFBvc2l0aW9uKTogRWRpdEhhbmRsZVtdIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBnZXRDdXJzb3IoeyBpc0RyYWdnaW5nIH06IHsgaXNEcmFnZ2luZzogYm9vbGVhbiB9KTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2NlbGwnO1xuICB9XG5cbiAgaXNTZWxlY3Rpb25QaWNrZWQocGlja3M6IERlY2tHTFBpY2tbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghcGlja3MubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcGlja2VkSW5kZXhlcyA9IHBpY2tzLm1hcCgoeyBpbmRleCB9KSA9PiBpbmRleCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRGZWF0dXJlSW5kZXhlcyA9IHRoaXMuZ2V0U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcygpO1xuICAgIHJldHVybiBzZWxlY3RlZEZlYXR1cmVJbmRleGVzLnNvbWUoaW5kZXggPT4gcGlja2VkSW5kZXhlcy5pbmNsdWRlcyhpbmRleCkpO1xuICB9XG5cbiAgZ2V0QWRkRmVhdHVyZUFjdGlvbihnZW9tZXRyeTogR2VvbWV0cnkpOiBFZGl0QWN0aW9uIHtcbiAgICAvLyBVbnN1cmUgd2h5IGZsb3cgY2FuJ3QgZGVhbCB3aXRoIEdlb21ldHJ5IHR5cGUsIGJ1dCB0aGVyZSBJIGZpeGVkIGl0XG4gICAgY29uc3QgZ2VvbWV0cnlBc0FueTogYW55ID0gZ2VvbWV0cnk7XG5cbiAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHRoaXMuZ2V0SW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24oKVxuICAgICAgLmFkZEZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlBc0FueVxuICAgICAgfSlcbiAgICAgIC5nZXRPYmplY3QoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGVkRGF0YSxcbiAgICAgIGVkaXRUeXBlOiAnYWRkRmVhdHVyZScsXG4gICAgICBmZWF0dXJlSW5kZXhlczogW3VwZGF0ZWREYXRhLmZlYXR1cmVzLmxlbmd0aCAtIDFdLFxuICAgICAgZWRpdENvbnRleHQ6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgZ2V0QWRkTWFueUZlYXR1cmVzQWN0aW9uKGZlYXR1cmVDb2xsZWN0aW9uOiBGZWF0dXJlQ29sbGVjdGlvbik6IEVkaXRBY3Rpb24ge1xuICAgIGNvbnN0IGZlYXR1cmVzID0gZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXM7XG4gICAgbGV0IHVwZGF0ZWREYXRhID0gdGhpcy5nZXRJbW11dGFibGVGZWF0dXJlQ29sbGVjdGlvbigpO1xuICAgIGNvbnN0IGluaXRpYWxJbmRleCA9IHVwZGF0ZWREYXRhLmdldE9iamVjdCgpLmZlYXR1cmVzLmxlbmd0aDtcbiAgICBjb25zdCB1cGRhdGVkSW5kZXhlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmVhdHVyZSBvZiBmZWF0dXJlcykge1xuICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzLCBnZW9tZXRyeSB9ID0gZmVhdHVyZTtcbiAgICAgIGNvbnN0IGdlb21ldHJ5QXNBbnk6IGFueSA9IGdlb21ldHJ5O1xuICAgICAgdXBkYXRlZERhdGEgPSB1cGRhdGVkRGF0YS5hZGRGZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlBc0FueVxuICAgICAgfSk7XG4gICAgICB1cGRhdGVkSW5kZXhlcy5wdXNoKGluaXRpYWxJbmRleCArIHVwZGF0ZWRJbmRleGVzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZWREYXRhOiB1cGRhdGVkRGF0YS5nZXRPYmplY3QoKSxcbiAgICAgIGVkaXRUeXBlOiAnYWRkRmVhdHVyZScsXG4gICAgICBmZWF0dXJlSW5kZXhlczogdXBkYXRlZEluZGV4ZXMsXG4gICAgICBlZGl0Q29udGV4dDogbnVsbFxuICAgIH07XG4gIH1cblxuICBnZXRBZGRGZWF0dXJlT3JCb29sZWFuUG9seWdvbkFjdGlvbihnZW9tZXRyeTogUG9seWdvbik6ID9FZGl0QWN0aW9uIHtcbiAgICBjb25zdCBzZWxlY3RlZEZlYXR1cmUgPSB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZSgpO1xuICAgIGNvbnN0IG1vZGVDb25maWcgPSB0aGlzLmdldE1vZGVDb25maWcoKTtcbiAgICBpZiAobW9kZUNvbmZpZyAmJiBtb2RlQ29uZmlnLmJvb2xlYW5PcGVyYXRpb24pIHtcbiAgICAgIGlmIChcbiAgICAgICAgIXNlbGVjdGVkRmVhdHVyZSB8fFxuICAgICAgICAoc2VsZWN0ZWRGZWF0dXJlLmdlb21ldHJ5LnR5cGUgIT09ICdQb2x5Z29uJyAmJlxuICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZS5nZW9tZXRyeS50eXBlICE9PSAnTXVsdGlQb2x5Z29uJylcbiAgICAgICkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSxuby11bmRlZlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ2Jvb2xlYW5PcGVyYXRpb24gb25seSBzdXBwb3J0ZWQgZm9yIHNpbmdsZSBQb2x5Z29uIG9yIE11bHRpUG9seWdvbiBzZWxlY3Rpb24nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmZWF0dXJlID0ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIGdlb21ldHJ5XG4gICAgICB9O1xuXG4gICAgICBsZXQgdXBkYXRlZEdlb21ldHJ5O1xuICAgICAgaWYgKG1vZGVDb25maWcuYm9vbGVhbk9wZXJhdGlvbiA9PT0gJ3VuaW9uJykge1xuICAgICAgICB1cGRhdGVkR2VvbWV0cnkgPSB0dXJmVW5pb24oc2VsZWN0ZWRGZWF0dXJlLCBmZWF0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZUNvbmZpZy5ib29sZWFuT3BlcmF0aW9uID09PSAnZGlmZmVyZW5jZScpIHtcbiAgICAgICAgdXBkYXRlZEdlb21ldHJ5ID0gdHVyZkRpZmZlcmVuY2Uoc2VsZWN0ZWRGZWF0dXJlLCBmZWF0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZUNvbmZpZy5ib29sZWFuT3BlcmF0aW9uID09PSAnaW50ZXJzZWN0aW9uJykge1xuICAgICAgICB1cGRhdGVkR2VvbWV0cnkgPSB0dXJmSW50ZXJzZWN0KHNlbGVjdGVkRmVhdHVyZSwgZmVhdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSxuby11bmRlZlxuICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgYm9vbGVhbk9wZXJhdGlvbiAke21vZGVDb25maWcuYm9vbGVhbk9wZXJhdGlvbn1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghdXBkYXRlZEdlb21ldHJ5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlLG5vLXVuZGVmXG4gICAgICAgIGNvbnNvbGUud2FybignQ2FuY2VsaW5nIGVkaXQuIEJvb2xlYW4gb3BlcmF0aW9uIGVyYXNlZCBlbnRpcmUgcG9seWdvbi4nKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZlYXR1cmVJbmRleCA9IHRoaXMuZ2V0U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcygpWzBdO1xuXG4gICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHRoaXMuZ2V0SW1tdXRhYmxlRmVhdHVyZUNvbGxlY3Rpb24oKVxuICAgICAgICAucmVwbGFjZUdlb21ldHJ5KGZlYXR1cmVJbmRleCwgdXBkYXRlZEdlb21ldHJ5Lmdlb21ldHJ5KVxuICAgICAgICAuZ2V0T2JqZWN0KCk7XG5cbiAgICAgIGNvbnN0IGVkaXRBY3Rpb246IEVkaXRBY3Rpb24gPSB7XG4gICAgICAgIHVwZGF0ZWREYXRhLFxuICAgICAgICBlZGl0VHlwZTogJ3VuaW9uR2VvbWV0cnknLFxuICAgICAgICBmZWF0dXJlSW5kZXhlczogW2ZlYXR1cmVJbmRleF0sXG4gICAgICAgIGVkaXRDb250ZXh0OiBudWxsXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZWRpdEFjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWRkRmVhdHVyZUFjdGlvbihnZW9tZXRyeSk7XG4gIH1cblxuICBoYW5kbGVDbGljayhldmVudDogQ2xpY2tFdmVudCk6ID9FZGl0QWN0aW9uIHtcbiAgICB0aGlzLl9jbGlja1NlcXVlbmNlLnB1c2goZXZlbnQuZ3JvdW5kQ29vcmRzKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaGFuZGxlUG9pbnRlck1vdmUoZXZlbnQ6IFBvaW50ZXJNb3ZlRXZlbnQpOiB7IGVkaXRBY3Rpb246ID9FZGl0QWN0aW9uLCBjYW5jZWxNYXBQYW46IGJvb2xlYW4gfSB7XG4gICAgcmV0dXJuIHsgZWRpdEFjdGlvbjogbnVsbCwgY2FuY2VsTWFwUGFuOiBmYWxzZSB9O1xuICB9XG5cbiAgaGFuZGxlU3RhcnREcmFnZ2luZyhldmVudDogU3RhcnREcmFnZ2luZ0V2ZW50KTogP0VkaXRBY3Rpb24ge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaGFuZGxlU3RvcERyYWdnaW5nKGV2ZW50OiBTdG9wRHJhZ2dpbmdFdmVudCk6ID9FZGl0QWN0aW9uIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGlja2VkRWRpdEhhbmRsZShwaWNrczogPyhhbnlbXSkpOiA/RWRpdEhhbmRsZSB7XG4gIGNvbnN0IGluZm8gPSBwaWNrcyAmJiBwaWNrcy5maW5kKHBpY2sgPT4gcGljay5pc0VkaXRpbmdIYW5kbGUpO1xuICBpZiAoaW5mbykge1xuICAgIHJldHVybiBpbmZvLm9iamVjdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybWVkaWF0ZVBvc2l0aW9uKHBvc2l0aW9uMTogUG9zaXRpb24sIHBvc2l0aW9uMjogUG9zaXRpb24pOiBQb3NpdGlvbiB7XG4gIGNvbnN0IGludGVybWVkaWF0ZVBvc2l0aW9uID0gW1xuICAgIChwb3NpdGlvbjFbMF0gKyBwb3NpdGlvbjJbMF0pIC8gMi4wLFxuICAgIChwb3NpdGlvbjFbMV0gKyBwb3NpdGlvbjJbMV0pIC8gMi4wXG4gIF07XG4gIHJldHVybiBpbnRlcm1lZGlhdGVQb3NpdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVkaXRIYW5kbGVzRm9yR2VvbWV0cnkoXG4gIGdlb21ldHJ5OiBHZW9tZXRyeSxcbiAgZmVhdHVyZUluZGV4OiBudW1iZXIsXG4gIGVkaXRIYW5kbGVUeXBlOiBFZGl0SGFuZGxlVHlwZSA9ICdleGlzdGluZydcbikge1xuICBsZXQgaGFuZGxlczogRWRpdEhhbmRsZVtdID0gW107XG5cbiAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgY2FzZSAnUG9pbnQnOlxuICAgICAgLy8gcG9zaXRpb25zIGFyZSBub3QgbmVzdGVkXG4gICAgICBoYW5kbGVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgcG9zaXRpb246IGdlb21ldHJ5LmNvb3JkaW5hdGVzLFxuICAgICAgICAgIHBvc2l0aW9uSW5kZXhlczogW10sXG4gICAgICAgICAgZmVhdHVyZUluZGV4LFxuICAgICAgICAgIHR5cGU6IGVkaXRIYW5kbGVUeXBlXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDEgbGV2ZWxcbiAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdChcbiAgICAgICAgZ2V0RWRpdEhhbmRsZXNGb3JDb29yZGluYXRlcyhnZW9tZXRyeS5jb29yZGluYXRlcywgW10sIGZlYXR1cmVJbmRleCwgZWRpdEhhbmRsZVR5cGUpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDIgbGV2ZWxzXG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLmNvbmNhdChcbiAgICAgICAgICBnZXRFZGl0SGFuZGxlc0ZvckNvb3JkaW5hdGVzKGdlb21ldHJ5LmNvb3JkaW5hdGVzW2FdLCBbYV0sIGZlYXR1cmVJbmRleCwgZWRpdEhhbmRsZVR5cGUpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAvLyBEb24ndCByZXBlYXQgdGhlIGZpcnN0L2xhc3QgaGFuZGxlIGZvciBQb2x5Z29uc1xuICAgICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgIC8vIHBvc2l0aW9ucyBhcmUgbmVzdGVkIDMgbGV2ZWxzXG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgZ2VvbWV0cnkuY29vcmRpbmF0ZXNbYV0ubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICBoYW5kbGVzID0gaGFuZGxlcy5jb25jYXQoXG4gICAgICAgICAgICBnZXRFZGl0SGFuZGxlc0ZvckNvb3JkaW5hdGVzKFxuICAgICAgICAgICAgICBnZW9tZXRyeS5jb29yZGluYXRlc1thXVtiXSxcbiAgICAgICAgICAgICAgW2EsIGJdLFxuICAgICAgICAgICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICAgICAgICAgIGVkaXRIYW5kbGVUeXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBEb24ndCByZXBlYXQgdGhlIGZpcnN0L2xhc3QgaGFuZGxlIGZvciBQb2x5Z29uc1xuICAgICAgICAgIGhhbmRsZXMgPSBoYW5kbGVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKGBVbmhhbmRsZWQgZ2VvbWV0cnkgdHlwZTogJHtnZW9tZXRyeS50eXBlfWApO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXM7XG59XG5cbmZ1bmN0aW9uIGdldEVkaXRIYW5kbGVzRm9yQ29vcmRpbmF0ZXMoXG4gIGNvb3JkaW5hdGVzOiBhbnlbXSxcbiAgcG9zaXRpb25JbmRleFByZWZpeDogbnVtYmVyW10sXG4gIGZlYXR1cmVJbmRleDogbnVtYmVyLFxuICBlZGl0SGFuZGxlVHlwZTogRWRpdEhhbmRsZVR5cGUgPSAnZXhpc3RpbmcnXG4pOiBFZGl0SGFuZGxlW10ge1xuICBjb25zdCBlZGl0SGFuZGxlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBjb29yZGluYXRlc1tpXTtcbiAgICBlZGl0SGFuZGxlcy5wdXNoKHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcG9zaXRpb25JbmRleGVzOiBbLi4ucG9zaXRpb25JbmRleFByZWZpeCwgaV0sXG4gICAgICBmZWF0dXJlSW5kZXgsXG4gICAgICB0eXBlOiBlZGl0SGFuZGxlVHlwZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBlZGl0SGFuZGxlcztcbn1cbiJdfQ==