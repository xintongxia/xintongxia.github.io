"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// Minimum number of pixels the pointer must move from the original pointer down to be considered dragging
var MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS = 7;

var EditableLayer =
/*#__PURE__*/
function (_CompositeLayer) {
  _inherits(EditableLayer, _CompositeLayer);

  function EditableLayer() {
    _classCallCheck(this, EditableLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(EditableLayer).apply(this, arguments));
  }

  _createClass(EditableLayer, [{
    key: "onLayerClick",
    // Overridable interaction event handlers
    value: function onLayerClick(event) {// default implementation - do nothing
    }
  }, {
    key: "onDoubleClick",
    value: function onDoubleClick(event) {// default implementation - do nothing
    }
  }, {
    key: "onStartDragging",
    value: function onStartDragging(event) {// default implementation - do nothing
    }
  }, {
    key: "onStopDragging",
    value: function onStopDragging(event) {// default implementation - do nothing
    }
  }, {
    key: "onPointerMove",
    value: function onPointerMove(event) {} // default implementation - do nothing
    // TODO: implement onCancelDragging (e.g. drag off screen)

  }, {
    key: "initializeState",
    value: function initializeState() {
      this.setState({
        _editableLayerState: {
          // Pointer event handlers
          pointerHandlers: null,
          // Picked objects at the time the pointer went down
          pointerDownPicks: null,
          // Screen coordinates where the pointer went down
          pointerDownScreenCoords: null,
          // Ground coordinates where the pointer went down
          pointerDownGroundCoords: null,
          // Is the pointer dragging (pointer down + moved at least MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS)
          isDragging: false
        }
      });
    }
  }, {
    key: "finalizeState",
    value: function finalizeState() {
      this._removePointerHandlers();
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          changeFlags = _ref.changeFlags;

      // unsubscribe previous layer instance's handlers
      this._removePointerHandlers();

      this._addPointerHandlers();
    }
  }, {
    key: "_removePointerHandlers",
    value: function _removePointerHandlers() {
      if (this.state._editableLayerState.pointerHandlers) {
        this.context.gl.canvas.removeEventListener('pointermove', this.state._editableLayerState.pointerHandlers.onPointerMove);
        this.context.gl.canvas.removeEventListener('pointerdown', this.state._editableLayerState.pointerHandlers.onPointerDown);
        this.context.gl.canvas.removeEventListener('pointerup', this.state._editableLayerState.pointerHandlers.onPointerUp);
        this.context.gl.canvas.removeEventListener('dblclick', this.state._editableLayerState.pointerHandlers.onDoubleClick);
      }

      this.state._editableLayerState.pointerHandlers = null;
    }
  }, {
    key: "_addPointerHandlers",
    value: function _addPointerHandlers() {
      this.state._editableLayerState.pointerHandlers = {
        onPointerMove: this._onPointerMove.bind(this),
        onPointerDown: this._onPointerDown.bind(this),
        onPointerUp: this._onPointerUp.bind(this),
        onDoubleClick: this._onDoubleClick.bind(this)
      };
      this.context.gl.canvas.addEventListener('pointermove', this.state._editableLayerState.pointerHandlers.onPointerMove);
      this.context.gl.canvas.addEventListener('pointerdown', this.state._editableLayerState.pointerHandlers.onPointerDown);
      this.context.gl.canvas.addEventListener('pointerup', this.state._editableLayerState.pointerHandlers.onPointerUp);
      this.context.gl.canvas.addEventListener('dblclick', this.state._editableLayerState.pointerHandlers.onDoubleClick);
    }
  }, {
    key: "_onDoubleClick",
    value: function _onDoubleClick(event) {
      var screenCoords = this.getScreenCoords(event);
      var groundCoords = this.getGroundCoords(screenCoords);
      this.onDoubleClick({
        groundCoords: groundCoords,
        sourceEvent: event
      });
    }
  }, {
    key: "_onPointerDown",
    value: function _onPointerDown(event) {
      var screenCoords = this.getScreenCoords(event);
      var groundCoords = this.getGroundCoords(screenCoords);
      var picks = this.context.deck.pickMultipleObjects({
        x: screenCoords[0],
        y: screenCoords[1],
        layerIds: [this.props.id],
        radius: 10,
        depth: 2
      });
      this.setState({
        _editableLayerState: _objectSpread({}, this.state._editableLayerState, {
          pointerDownScreenCoords: screenCoords,
          pointerDownGroundCoords: groundCoords,
          pointerDownPicks: picks,
          isDragging: false
        })
      });
    }
  }, {
    key: "_onPointerMove",
    value: function _onPointerMove(event) {
      var screenCoords = this.getScreenCoords(event);
      var groundCoords = this.getGroundCoords(screenCoords);
      var _this$state$_editable = this.state._editableLayerState,
          pointerDownPicks = _this$state$_editable.pointerDownPicks,
          pointerDownScreenCoords = _this$state$_editable.pointerDownScreenCoords,
          pointerDownGroundCoords = _this$state$_editable.pointerDownGroundCoords;
      var isDragging = this.state._editableLayerState.isDragging;

      if (pointerDownScreenCoords) {
        // Pointer went down and is moving
        // Did it move enough to consider it a drag
        if (!isDragging && this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {
          // OK, this is considered dragging
          // Fire the start dragging event
          this.onStartDragging({
            picks: pointerDownPicks,
            screenCoords: screenCoords,
            groundCoords: groundCoords,
            pointerDownScreenCoords: pointerDownScreenCoords,
            pointerDownGroundCoords: pointerDownGroundCoords,
            sourceEvent: event
          });
          isDragging = true;
          this.setState({
            _editableLayerState: _objectSpread({}, this.state._editableLayerState, {
              isDragging: isDragging
            })
          });
        }
      }

      var picks = this.context.deck.pickMultipleObjects({
        x: screenCoords[0],
        y: screenCoords[1],
        layerIds: [this.props.id],
        radius: 10,
        depth: 2
      });
      this.onPointerMove({
        screenCoords: screenCoords,
        groundCoords: groundCoords,
        picks: picks,
        isDragging: isDragging,
        pointerDownPicks: pointerDownPicks,
        pointerDownScreenCoords: pointerDownScreenCoords,
        pointerDownGroundCoords: pointerDownGroundCoords,
        sourceEvent: event
      });
    }
  }, {
    key: "_onPointerUp",
    value: function _onPointerUp(event) {
      var screenCoords = this.getScreenCoords(event);
      var groundCoords = this.getGroundCoords(screenCoords);
      var _this$state$_editable2 = this.state._editableLayerState,
          pointerDownPicks = _this$state$_editable2.pointerDownPicks,
          pointerDownScreenCoords = _this$state$_editable2.pointerDownScreenCoords,
          pointerDownGroundCoords = _this$state$_editable2.pointerDownGroundCoords,
          isDragging = _this$state$_editable2.isDragging;

      if (!pointerDownScreenCoords) {
        // This is a pointer up without a pointer down (e.g. user pointer downed elsewhere), so ignore
        return;
      }

      if (isDragging) {
        this.onStopDragging({
          picks: pointerDownPicks,
          screenCoords: screenCoords,
          groundCoords: groundCoords,
          pointerDownScreenCoords: pointerDownScreenCoords,
          pointerDownGroundCoords: pointerDownGroundCoords,
          sourceEvent: event
        });
      } else if (!this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {
        this.onLayerClick({
          picks: pointerDownPicks,
          screenCoords: screenCoords,
          groundCoords: groundCoords,
          sourceEvent: event
        });
      }

      this.setState({
        _editableLayerState: _objectSpread({}, this.state._editableLayerState, {
          pointerDownScreenCoords: null,
          pointerDownGroundCoords: null,
          pointerDownPicks: null,
          isDragging: false
        })
      });
    }
  }, {
    key: "getScreenCoords",
    value: function getScreenCoords(pointerEvent) {
      return [pointerEvent.clientX - this.context.gl.canvas.getBoundingClientRect().x, pointerEvent.clientY - this.context.gl.canvas.getBoundingClientRect().y];
    }
  }, {
    key: "getGroundCoords",
    value: function getGroundCoords(screenCoords) {
      return this.context.viewport.unproject([screenCoords[0], screenCoords[1]]);
    }
  }, {
    key: "movedEnoughForDrag",
    value: function movedEnoughForDrag(screenCoords1, screenCoords2) {
      return Math.abs(screenCoords1[0] - screenCoords2[0]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS || Math.abs(screenCoords1[1] - screenCoords2[1]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS;
    }
  }]);

  return EditableLayer;
}(_core.CompositeLayer);

exports.default = EditableLayer;
EditableLayer.layerName = 'EditableLayer';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXllcnMvZWRpdGFibGUtbGF5ZXIuanMiXSwibmFtZXMiOlsiTUlOSU1VTV9QT0lOVEVSX01PVkVfVEhSRVNIT0xEX1BJWEVMUyIsIkVkaXRhYmxlTGF5ZXIiLCJldmVudCIsInNldFN0YXRlIiwiX2VkaXRhYmxlTGF5ZXJTdGF0ZSIsInBvaW50ZXJIYW5kbGVycyIsInBvaW50ZXJEb3duUGlja3MiLCJwb2ludGVyRG93blNjcmVlbkNvb3JkcyIsInBvaW50ZXJEb3duR3JvdW5kQ29vcmRzIiwiaXNEcmFnZ2luZyIsIl9yZW1vdmVQb2ludGVySGFuZGxlcnMiLCJwcm9wcyIsImNoYW5nZUZsYWdzIiwiX2FkZFBvaW50ZXJIYW5kbGVycyIsInN0YXRlIiwiY29udGV4dCIsImdsIiwiY2FudmFzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uUG9pbnRlck1vdmUiLCJvblBvaW50ZXJEb3duIiwib25Qb2ludGVyVXAiLCJvbkRvdWJsZUNsaWNrIiwiX29uUG9pbnRlck1vdmUiLCJiaW5kIiwiX29uUG9pbnRlckRvd24iLCJfb25Qb2ludGVyVXAiLCJfb25Eb3VibGVDbGljayIsImFkZEV2ZW50TGlzdGVuZXIiLCJzY3JlZW5Db29yZHMiLCJnZXRTY3JlZW5Db29yZHMiLCJncm91bmRDb29yZHMiLCJnZXRHcm91bmRDb29yZHMiLCJzb3VyY2VFdmVudCIsInBpY2tzIiwiZGVjayIsInBpY2tNdWx0aXBsZU9iamVjdHMiLCJ4IiwieSIsImxheWVySWRzIiwiaWQiLCJyYWRpdXMiLCJkZXB0aCIsIm1vdmVkRW5vdWdoRm9yRHJhZyIsIm9uU3RhcnREcmFnZ2luZyIsIm9uU3RvcERyYWdnaW5nIiwib25MYXllckNsaWNrIiwicG9pbnRlckV2ZW50IiwiY2xpZW50WCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFkiLCJ2aWV3cG9ydCIsInVucHJvamVjdCIsInNjcmVlbkNvb3JkczEiLCJzY3JlZW5Db29yZHMyIiwiTWF0aCIsImFi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QkMsTUFBaEIsQ0FBdUJnQyxxQkFBdkIsR0FBK0NaLENBRGpFLEVBRUxVLFlBQVksQ0FBQ0csT0FBYixHQUF1QixLQUFLbkMsT0FBTCxDQUFhQyxFQUFiLENBQWdCQyxNQUFoQixDQUF1QmdDLHFCQUF2QixHQUErQ1gsQ0FGakUsQ0FBUDtBQUlEOzs7b0NBRWVULFksRUFBd0I7QUFDdEMsYUFBTyxLQUFLZCxPQUFMLENBQWFvQyxRQUFiLENBQXNCQyxTQUF0QixDQUFnQyxDQUFDdkIsWUFBWSxDQUFDLENBQUQsQ0FBYixFQUFrQkEsWUFBWSxDQUFDLENBQUQsQ0FBOUIsQ0FBaEMsQ0FBUDtBQUNEOzs7dUNBRWtCd0IsYSxFQUF5QkMsYSxFQUF5QjtBQUNuRSxhQUNFQyxJQUFJLENBQUNDLEdBQUwsQ0FBU0gsYUFBYSxDQUFDLENBQUQsQ0FBYixHQUFtQkMsYUFBYSxDQUFDLENBQUQsQ0FBekMsSUFBZ0R0RCxxQ0FBaEQsSUFDQXVELElBQUksQ0FBQ0MsR0FBTCxDQUFTSCxhQUFhLENBQUMsQ0FBRCxDQUFiLEdBQW1CQyxhQUFhLENBQUMsQ0FBRCxDQUF6QyxJQUFnRHRELHFDQUZsRDtBQUlEOzs7O0VBM1B3Q3lELG9COzs7QUE4UDNDeEQsYUFBYSxDQUFDeUQsU0FBZCxHQUEwQixlQUExQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuaW1wb3J0IHsgQ29tcG9zaXRlTGF5ZXIgfSBmcm9tICdAZGVjay5nbC9jb3JlJztcbmltcG9ydCB0eXBlIHtcbiAgQ2xpY2tFdmVudCxcbiAgU3RhcnREcmFnZ2luZ0V2ZW50LFxuICBTdG9wRHJhZ2dpbmdFdmVudCxcbiAgUG9pbnRlck1vdmVFdmVudCxcbiAgRG91YmxlQ2xpY2tFdmVudFxufSBmcm9tICcuLi9ldmVudC10eXBlcy5qcyc7XG5cbi8vIE1pbmltdW0gbnVtYmVyIG9mIHBpeGVscyB0aGUgcG9pbnRlciBtdXN0IG1vdmUgZnJvbSB0aGUgb3JpZ2luYWwgcG9pbnRlciBkb3duIHRvIGJlIGNvbnNpZGVyZWQgZHJhZ2dpbmdcbmNvbnN0IE1JTklNVU1fUE9JTlRFUl9NT1ZFX1RIUkVTSE9MRF9QSVhFTFMgPSA3O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGl0YWJsZUxheWVyIGV4dGVuZHMgQ29tcG9zaXRlTGF5ZXIge1xuICAvLyBPdmVycmlkYWJsZSBpbnRlcmFjdGlvbiBldmVudCBoYW5kbGVyc1xuICBvbkxheWVyQ2xpY2soZXZlbnQ6IENsaWNrRXZlbnQpIHtcbiAgICAvLyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIC0gZG8gbm90aGluZ1xuICB9XG5cbiAgb25Eb3VibGVDbGljayhldmVudDogRG91YmxlQ2xpY2tFdmVudCkge1xuICAgIC8vIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gLSBkbyBub3RoaW5nXG4gIH1cblxuICBvblN0YXJ0RHJhZ2dpbmcoZXZlbnQ6IFN0YXJ0RHJhZ2dpbmdFdmVudCkge1xuICAgIC8vIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gLSBkbyBub3RoaW5nXG4gIH1cblxuICBvblN0b3BEcmFnZ2luZyhldmVudDogU3RvcERyYWdnaW5nRXZlbnQpIHtcbiAgICAvLyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIC0gZG8gbm90aGluZ1xuICB9XG5cbiAgb25Qb2ludGVyTW92ZShldmVudDogUG9pbnRlck1vdmVFdmVudCkge1xuICAgIC8vIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gLSBkbyBub3RoaW5nXG4gIH1cblxuICAvLyBUT0RPOiBpbXBsZW1lbnQgb25DYW5jZWxEcmFnZ2luZyAoZS5nLiBkcmFnIG9mZiBzY3JlZW4pXG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgX2VkaXRhYmxlTGF5ZXJTdGF0ZToge1xuICAgICAgICAvLyBQb2ludGVyIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIHBvaW50ZXJIYW5kbGVyczogbnVsbCxcbiAgICAgICAgLy8gUGlja2VkIG9iamVjdHMgYXQgdGhlIHRpbWUgdGhlIHBvaW50ZXIgd2VudCBkb3duXG4gICAgICAgIHBvaW50ZXJEb3duUGlja3M6IG51bGwsXG4gICAgICAgIC8vIFNjcmVlbiBjb29yZGluYXRlcyB3aGVyZSB0aGUgcG9pbnRlciB3ZW50IGRvd25cbiAgICAgICAgcG9pbnRlckRvd25TY3JlZW5Db29yZHM6IG51bGwsXG4gICAgICAgIC8vIEdyb3VuZCBjb29yZGluYXRlcyB3aGVyZSB0aGUgcG9pbnRlciB3ZW50IGRvd25cbiAgICAgICAgcG9pbnRlckRvd25Hcm91bmRDb29yZHM6IG51bGwsXG4gICAgICAgIC8vIElzIHRoZSBwb2ludGVyIGRyYWdnaW5nIChwb2ludGVyIGRvd24gKyBtb3ZlZCBhdCBsZWFzdCBNSU5JTVVNX1BPSU5URVJfTU9WRV9USFJFU0hPTERfUElYRUxTKVxuICAgICAgICBpc0RyYWdnaW5nOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZmluYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLl9yZW1vdmVQb2ludGVySGFuZGxlcnMoKTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHsgcHJvcHMsIGNoYW5nZUZsYWdzIH06IE9iamVjdCkge1xuICAgIC8vIHVuc3Vic2NyaWJlIHByZXZpb3VzIGxheWVyIGluc3RhbmNlJ3MgaGFuZGxlcnNcbiAgICB0aGlzLl9yZW1vdmVQb2ludGVySGFuZGxlcnMoKTtcbiAgICB0aGlzLl9hZGRQb2ludGVySGFuZGxlcnMoKTtcbiAgfVxuXG4gIF9yZW1vdmVQb2ludGVySGFuZGxlcnMoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuX2VkaXRhYmxlTGF5ZXJTdGF0ZS5wb2ludGVySGFuZGxlcnMpIHtcbiAgICAgIHRoaXMuY29udGV4dC5nbC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgdGhpcy5zdGF0ZS5fZWRpdGFibGVMYXllclN0YXRlLnBvaW50ZXJIYW5kbGVycy5vblBvaW50ZXJNb3ZlXG4gICAgICApO1xuICAgICAgdGhpcy5jb250ZXh0LmdsLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAncG9pbnRlcmRvd24nLFxuICAgICAgICB0aGlzLnN0YXRlLl9lZGl0YWJsZUxheWVyU3RhdGUucG9pbnRlckhhbmRsZXJzLm9uUG9pbnRlckRvd25cbiAgICAgICk7XG4gICAgICB0aGlzLmNvbnRleHQuZ2wuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdwb2ludGVydXAnLFxuICAgICAgICB0aGlzLnN0YXRlLl9lZGl0YWJsZUxheWVyU3RhdGUucG9pbnRlckhhbmRsZXJzLm9uUG9pbnRlclVwXG4gICAgICApO1xuICAgICAgdGhpcy5jb250ZXh0LmdsLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAnZGJsY2xpY2snLFxuICAgICAgICB0aGlzLnN0YXRlLl9lZGl0YWJsZUxheWVyU3RhdGUucG9pbnRlckhhbmRsZXJzLm9uRG91YmxlQ2xpY2tcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuX2VkaXRhYmxlTGF5ZXJTdGF0ZS5wb2ludGVySGFuZGxlcnMgPSBudWxsO1xuICB9XG5cbiAgX2FkZFBvaW50ZXJIYW5kbGVycygpIHtcbiAgICB0aGlzLnN0YXRlLl9lZGl0YWJsZUxheWVyU3RhdGUucG9pbnRlckhhbmRsZXJzID0ge1xuICAgICAgb25Qb2ludGVyTW92ZTogdGhpcy5fb25Qb2ludGVyTW92ZS5iaW5kKHRoaXMpLFxuICAgICAgb25Qb2ludGVyRG93bjogdGhpcy5fb25Qb2ludGVyRG93bi5iaW5kKHRoaXMpLFxuICAgICAgb25Qb2ludGVyVXA6IHRoaXMuX29uUG9pbnRlclVwLmJpbmQodGhpcyksXG4gICAgICBvbkRvdWJsZUNsaWNrOiB0aGlzLl9vbkRvdWJsZUNsaWNrLmJpbmQodGhpcylcbiAgICB9O1xuXG4gICAgdGhpcy5jb250ZXh0LmdsLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgIHRoaXMuc3RhdGUuX2VkaXRhYmxlTGF5ZXJTdGF0ZS5wb2ludGVySGFuZGxlcnMub25Qb2ludGVyTW92ZVxuICAgICk7XG4gICAgdGhpcy5jb250ZXh0LmdsLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ3BvaW50ZXJkb3duJyxcbiAgICAgIHRoaXMuc3RhdGUuX2VkaXRhYmxlTGF5ZXJTdGF0ZS5wb2ludGVySGFuZGxlcnMub25Qb2ludGVyRG93blxuICAgICk7XG4gICAgdGhpcy5jb250ZXh0LmdsLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ3BvaW50ZXJ1cCcsXG4gICAgICB0aGlzLnN0YXRlLl9lZGl0YWJsZUxheWVyU3RhdGUucG9pbnRlckhhbmRsZXJzLm9uUG9pbnRlclVwXG4gICAgKTtcbiAgICB0aGlzLmNvbnRleHQuZ2wuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnZGJsY2xpY2snLFxuICAgICAgdGhpcy5zdGF0ZS5fZWRpdGFibGVMYXllclN0YXRlLnBvaW50ZXJIYW5kbGVycy5vbkRvdWJsZUNsaWNrXG4gICAgKTtcbiAgfVxuXG4gIF9vbkRvdWJsZUNsaWNrKGV2ZW50OiBPYmplY3QpIHtcbiAgICBjb25zdCBzY3JlZW5Db29yZHMgPSB0aGlzLmdldFNjcmVlbkNvb3JkcyhldmVudCk7XG4gICAgY29uc3QgZ3JvdW5kQ29vcmRzID0gdGhpcy5nZXRHcm91bmRDb29yZHMoc2NyZWVuQ29vcmRzKTtcbiAgICB0aGlzLm9uRG91YmxlQ2xpY2soe1xuICAgICAgZ3JvdW5kQ29vcmRzLFxuICAgICAgc291cmNlRXZlbnQ6IGV2ZW50XG4gICAgfSk7XG4gIH1cblxuICBfb25Qb2ludGVyRG93bihldmVudDogT2JqZWN0KSB7XG4gICAgY29uc3Qgc2NyZWVuQ29vcmRzID0gdGhpcy5nZXRTY3JlZW5Db29yZHMoZXZlbnQpO1xuICAgIGNvbnN0IGdyb3VuZENvb3JkcyA9IHRoaXMuZ2V0R3JvdW5kQ29vcmRzKHNjcmVlbkNvb3Jkcyk7XG5cbiAgICBjb25zdCBwaWNrcyA9IHRoaXMuY29udGV4dC5kZWNrLnBpY2tNdWx0aXBsZU9iamVjdHMoe1xuICAgICAgeDogc2NyZWVuQ29vcmRzWzBdLFxuICAgICAgeTogc2NyZWVuQ29vcmRzWzFdLFxuICAgICAgbGF5ZXJJZHM6IFt0aGlzLnByb3BzLmlkXSxcbiAgICAgIHJhZGl1czogMTAsXG4gICAgICBkZXB0aDogMlxuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBfZWRpdGFibGVMYXllclN0YXRlOiB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUuX2VkaXRhYmxlTGF5ZXJTdGF0ZSxcbiAgICAgICAgcG9pbnRlckRvd25TY3JlZW5Db29yZHM6IHNjcmVlbkNvb3JkcyxcbiAgICAgICAgcG9pbnRlckRvd25Hcm91bmRDb29yZHM6IGdyb3VuZENvb3JkcyxcbiAgICAgICAgcG9pbnRlckRvd25QaWNrczogcGlja3MsXG4gICAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfb25Qb2ludGVyTW92ZShldmVudDogT2JqZWN0KSB7XG4gICAgY29uc3Qgc2NyZWVuQ29vcmRzID0gdGhpcy5nZXRTY3JlZW5Db29yZHMoZXZlbnQpO1xuICAgIGNvbnN0IGdyb3VuZENvb3JkcyA9IHRoaXMuZ2V0R3JvdW5kQ29vcmRzKHNjcmVlbkNvb3Jkcyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBwb2ludGVyRG93blBpY2tzLFxuICAgICAgcG9pbnRlckRvd25TY3JlZW5Db29yZHMsXG4gICAgICBwb2ludGVyRG93bkdyb3VuZENvb3Jkc1xuICAgIH0gPSB0aGlzLnN0YXRlLl9lZGl0YWJsZUxheWVyU3RhdGU7XG5cbiAgICBsZXQgeyBpc0RyYWdnaW5nIH0gPSB0aGlzLnN0YXRlLl9lZGl0YWJsZUxheWVyU3RhdGU7XG5cbiAgICBpZiAocG9pbnRlckRvd25TY3JlZW5Db29yZHMpIHtcbiAgICAgIC8vIFBvaW50ZXIgd2VudCBkb3duIGFuZCBpcyBtb3ZpbmdcblxuICAgICAgLy8gRGlkIGl0IG1vdmUgZW5vdWdoIHRvIGNvbnNpZGVyIGl0IGEgZHJhZ1xuICAgICAgaWYgKCFpc0RyYWdnaW5nICYmIHRoaXMubW92ZWRFbm91Z2hGb3JEcmFnKHBvaW50ZXJEb3duU2NyZWVuQ29vcmRzLCBzY3JlZW5Db29yZHMpKSB7XG4gICAgICAgIC8vIE9LLCB0aGlzIGlzIGNvbnNpZGVyZWQgZHJhZ2dpbmdcblxuICAgICAgICAvLyBGaXJlIHRoZSBzdGFydCBkcmFnZ2luZyBldmVudFxuICAgICAgICB0aGlzLm9uU3RhcnREcmFnZ2luZyh7XG4gICAgICAgICAgcGlja3M6IHBvaW50ZXJEb3duUGlja3MsXG4gICAgICAgICAgc2NyZWVuQ29vcmRzLFxuICAgICAgICAgIGdyb3VuZENvb3JkcyxcbiAgICAgICAgICBwb2ludGVyRG93blNjcmVlbkNvb3JkcyxcbiAgICAgICAgICBwb2ludGVyRG93bkdyb3VuZENvb3JkcyxcbiAgICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIF9lZGl0YWJsZUxheWVyU3RhdGU6IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RhdGUuX2VkaXRhYmxlTGF5ZXJTdGF0ZSxcbiAgICAgICAgICAgIGlzRHJhZ2dpbmdcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBpY2tzID0gdGhpcy5jb250ZXh0LmRlY2sucGlja011bHRpcGxlT2JqZWN0cyh7XG4gICAgICB4OiBzY3JlZW5Db29yZHNbMF0sXG4gICAgICB5OiBzY3JlZW5Db29yZHNbMV0sXG4gICAgICBsYXllcklkczogW3RoaXMucHJvcHMuaWRdLFxuICAgICAgcmFkaXVzOiAxMCxcbiAgICAgIGRlcHRoOiAyXG4gICAgfSk7XG5cbiAgICB0aGlzLm9uUG9pbnRlck1vdmUoe1xuICAgICAgc2NyZWVuQ29vcmRzLFxuICAgICAgZ3JvdW5kQ29vcmRzLFxuICAgICAgcGlja3MsXG4gICAgICBpc0RyYWdnaW5nLFxuICAgICAgcG9pbnRlckRvd25QaWNrcyxcbiAgICAgIHBvaW50ZXJEb3duU2NyZWVuQ29vcmRzLFxuICAgICAgcG9pbnRlckRvd25Hcm91bmRDb29yZHMsXG4gICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgfVxuXG4gIF9vblBvaW50ZXJVcChldmVudDogT2JqZWN0KSB7XG4gICAgY29uc3Qgc2NyZWVuQ29vcmRzID0gdGhpcy5nZXRTY3JlZW5Db29yZHMoZXZlbnQpO1xuICAgIGNvbnN0IGdyb3VuZENvb3JkcyA9IHRoaXMuZ2V0R3JvdW5kQ29vcmRzKHNjcmVlbkNvb3Jkcyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBwb2ludGVyRG93blBpY2tzLFxuICAgICAgcG9pbnRlckRvd25TY3JlZW5Db29yZHMsXG4gICAgICBwb2ludGVyRG93bkdyb3VuZENvb3JkcyxcbiAgICAgIGlzRHJhZ2dpbmdcbiAgICB9ID0gdGhpcy5zdGF0ZS5fZWRpdGFibGVMYXllclN0YXRlO1xuXG4gICAgaWYgKCFwb2ludGVyRG93blNjcmVlbkNvb3Jkcykge1xuICAgICAgLy8gVGhpcyBpcyBhIHBvaW50ZXIgdXAgd2l0aG91dCBhIHBvaW50ZXIgZG93biAoZS5nLiB1c2VyIHBvaW50ZXIgZG93bmVkIGVsc2V3aGVyZSksIHNvIGlnbm9yZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0RyYWdnaW5nKSB7XG4gICAgICB0aGlzLm9uU3RvcERyYWdnaW5nKHtcbiAgICAgICAgcGlja3M6IHBvaW50ZXJEb3duUGlja3MsXG4gICAgICAgIHNjcmVlbkNvb3JkcyxcbiAgICAgICAgZ3JvdW5kQ29vcmRzLFxuICAgICAgICBwb2ludGVyRG93blNjcmVlbkNvb3JkcyxcbiAgICAgICAgcG9pbnRlckRvd25Hcm91bmRDb29yZHMsXG4gICAgICAgIHNvdXJjZUV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5tb3ZlZEVub3VnaEZvckRyYWcocG9pbnRlckRvd25TY3JlZW5Db29yZHMsIHNjcmVlbkNvb3JkcykpIHtcbiAgICAgIHRoaXMub25MYXllckNsaWNrKHtcbiAgICAgICAgcGlja3M6IHBvaW50ZXJEb3duUGlja3MsXG4gICAgICAgIHNjcmVlbkNvb3JkcyxcbiAgICAgICAgZ3JvdW5kQ29vcmRzLFxuICAgICAgICBzb3VyY2VFdmVudDogZXZlbnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgX2VkaXRhYmxlTGF5ZXJTdGF0ZToge1xuICAgICAgICAuLi50aGlzLnN0YXRlLl9lZGl0YWJsZUxheWVyU3RhdGUsXG4gICAgICAgIHBvaW50ZXJEb3duU2NyZWVuQ29vcmRzOiBudWxsLFxuICAgICAgICBwb2ludGVyRG93bkdyb3VuZENvb3JkczogbnVsbCxcbiAgICAgICAgcG9pbnRlckRvd25QaWNrczogbnVsbCxcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldFNjcmVlbkNvb3Jkcyhwb2ludGVyRXZlbnQ6IE9iamVjdCkge1xuICAgIHJldHVybiBbXG4gICAgICBwb2ludGVyRXZlbnQuY2xpZW50WCAtIHRoaXMuY29udGV4dC5nbC5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueCxcbiAgICAgIHBvaW50ZXJFdmVudC5jbGllbnRZIC0gdGhpcy5jb250ZXh0LmdsLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS55XG4gICAgXTtcbiAgfVxuXG4gIGdldEdyb3VuZENvb3JkcyhzY3JlZW5Db29yZHM6IG51bWJlcltdKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC52aWV3cG9ydC51bnByb2plY3QoW3NjcmVlbkNvb3Jkc1swXSwgc2NyZWVuQ29vcmRzWzFdXSk7XG4gIH1cblxuICBtb3ZlZEVub3VnaEZvckRyYWcoc2NyZWVuQ29vcmRzMTogbnVtYmVyW10sIHNjcmVlbkNvb3JkczI6IG51bWJlcltdKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIE1hdGguYWJzKHNjcmVlbkNvb3JkczFbMF0gLSBzY3JlZW5Db29yZHMyWzBdKSA+IE1JTklNVU1fUE9JTlRFUl9NT1ZFX1RIUkVTSE9MRF9QSVhFTFMgfHxcbiAgICAgIE1hdGguYWJzKHNjcmVlbkNvb3JkczFbMV0gLSBzY3JlZW5Db29yZHMyWzFdKSA+IE1JTklNVU1fUE9JTlRFUl9NT1ZFX1RIUkVTSE9MRF9QSVhFTFNcbiAgICApO1xuICB9XG59XG5cbkVkaXRhYmxlTGF5ZXIubGF5ZXJOYW1lID0gJ0VkaXRhYmxlTGF5ZXInO1xuIl19