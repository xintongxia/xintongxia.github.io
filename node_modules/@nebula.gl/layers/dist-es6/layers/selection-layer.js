"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SELECTION_TYPE = void 0;

var _core = require("@deck.gl/core");

var _layers = require("@deck.gl/layers");

var _helpers = require("@turf/helpers");

var _buffer = _interopRequireDefault(require("@turf/buffer"));

var _difference = _interopRequireDefault(require("@turf/difference"));

var _editableGeojsonLayer = _interopRequireDefault(require("./editable-geojson-layer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SELECTION_TYPE = {
  NONE: null,
  RECTANGLE: 'rectangle',
  POLYGON: 'polygon'
};
exports.SELECTION_TYPE = SELECTION_TYPE;
var defaultProps = {
  selectionType: SELECTION_TYPE.RECTANGLE,
  layerIds: [],
  onSelect: function onSelect() {}
};
var EMPTY_DATA = {
  type: 'FeatureCollection',
  features: []
};
var EXPANSION_KM = 50;
var LAYER_ID_GEOJSON = 'selection-geojson';
var LAYER_ID_BLOCKER = 'selection-blocker';
var PASS_THROUGH_PROPS = ['lineWidthScale', 'lineWidthMinPixels', 'lineWidthMaxPixels', 'lineJointRounded', 'lineMiterLimit', 'pointRadiusScale', 'pointRadiusMinPixels', 'pointRadiusMaxPixels', 'lineDashJustified', 'getLineColor', 'getFillColor', 'getRadius', 'getLineWidth', 'getLineDashArray', 'getTentativeLineDashArray', 'getTentativeLineColor', 'getTentativeFillColor', 'getTentativeLineWidth'];

var SelectionLayer =
/*#__PURE__*/
function (_CompositeLayer) {
  _inherits(SelectionLayer, _CompositeLayer);

  function SelectionLayer() {
    _classCallCheck(this, SelectionLayer);

    return _possibleConstructorReturn(this, _getPrototypeOf(SelectionLayer).apply(this, arguments));
  }

  _createClass(SelectionLayer, [{
    key: "_selectRectangleObjects",
    value: function _selectRectangleObjects(coordinates) {
      var _this$props = this.props,
          layerIds = _this$props.layerIds,
          onSelect = _this$props.onSelect;

      var _this$context$viewpor = this.context.viewport.project(coordinates[0][0]),
          _this$context$viewpor2 = _slicedToArray(_this$context$viewpor, 2),
          x1 = _this$context$viewpor2[0],
          y1 = _this$context$viewpor2[1];

      var _this$context$viewpor3 = this.context.viewport.project(coordinates[0][2]),
          _this$context$viewpor4 = _slicedToArray(_this$context$viewpor3, 2),
          x2 = _this$context$viewpor4[0],
          y2 = _this$context$viewpor4[1];

      var pickingInfos = this.context.layerManager.pickObjects({
        viewports: [this.context.viewport],
        x: Math.min(x1, x2),
        y: Math.min(y1, y2),
        width: Math.abs(x2 - x1),
        height: Math.abs(y2 - y1),
        layerIds: layerIds
      });
      onSelect({
        pickingInfos: pickingInfos
      });
    }
  }, {
    key: "_selectPolygonObjects",
    value: function _selectPolygonObjects(coordinates) {
      var _this = this;

      var _this$props2 = this.props,
          layerIds = _this$props2.layerIds,
          onSelect = _this$props2.onSelect;
      var mousePoints = coordinates[0].map(function (c) {
        return _this.context.viewport.project(c);
      });
      var allX = mousePoints.map(function (mousePoint) {
        return mousePoint[0];
      });
      var allY = mousePoints.map(function (mousePoint) {
        return mousePoint[1];
      });
      var x = Math.min.apply(Math, _toConsumableArray(allX));
      var y = Math.min.apply(Math, _toConsumableArray(allY));
      var maxX = Math.max.apply(Math, _toConsumableArray(allX));
      var maxY = Math.max.apply(Math, _toConsumableArray(allY)); // Use a polygon to hide the outside, because pickObjects()
      // does not support polygons

      var landPointsPoly = (0, _helpers.polygon)(coordinates);
      var bigBuffer = (0, _buffer.default)(landPointsPoly, EXPANSION_KM);
      var bigPolygon;

      try {
        // turfDifference throws an exception if the polygon
        // intersects with itself (TODO: check if true in all versions)
        bigPolygon = (0, _difference.default)(bigBuffer, landPointsPoly);
      } catch (e) {
        // invalid selection polygon
        console.log('turfDifference() error', e); // eslint-disable-line

        return;
      }

      this.setState({
        pendingPolygonSelection: {
          bigPolygon: bigPolygon
        }
      });
      var blockerId = "".concat(this.props.id, "-").concat(LAYER_ID_BLOCKER); // HACK, find a better way

      setTimeout(function () {
        var pickingInfos = _this.context.layerManager.pickObjects({
          viewports: [_this.context.viewport],
          x: x,
          y: y,
          width: maxX - x,
          height: maxY - y,
          layerIds: [blockerId].concat(_toConsumableArray(layerIds))
        });

        onSelect({
          pickingInfos: pickingInfos.filter(function (item) {
            return item.layer.id !== _this.props.id;
          })
        });
      }, 250);
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      var _SELECTION_TYPE$RECTA,
          _this2 = this;

      var pendingPolygonSelection = this.state.pendingPolygonSelection;
      var mode = (_SELECTION_TYPE$RECTA = {}, _defineProperty(_SELECTION_TYPE$RECTA, SELECTION_TYPE.RECTANGLE, 'drawRectangle'), _defineProperty(_SELECTION_TYPE$RECTA, SELECTION_TYPE.POLYGON, 'drawPolygon'), _SELECTION_TYPE$RECTA)[this.props.selectionType] || 'view';
      var inheritedProps = {};
      PASS_THROUGH_PROPS.forEach(function (p) {
        if (_this2.props[p] !== undefined) inheritedProps[p] = _this2.props[p];
      });
      var layers = [new _editableGeojsonLayer.default(this.getSubLayerProps(_objectSpread({
        id: LAYER_ID_GEOJSON,
        pickable: true,
        mode: mode,
        selectedFeatureIndexes: [],
        data: EMPTY_DATA,
        onEdit: function onEdit(_ref) {
          var updatedData = _ref.updatedData,
              editType = _ref.editType;

          if (editType === 'addFeature') {
            var coordinates = updatedData.features[0].geometry.coordinates;

            if (_this2.props.selectionType === SELECTION_TYPE.RECTANGLE) {
              _this2._selectRectangleObjects(coordinates);
            } else if (_this2.props.selectionType === SELECTION_TYPE.POLYGON) {
              _this2._selectPolygonObjects(coordinates);
            }
          }
        }
      }, inheritedProps)))];

      if (pendingPolygonSelection) {
        var bigPolygon = pendingPolygonSelection.bigPolygon;
        layers.push(new _layers.PolygonLayer(this.getSubLayerProps({
          id: LAYER_ID_BLOCKER,
          pickable: true,
          stroked: false,
          opacity: 1.0,
          data: [bigPolygon],
          getLineColor: function getLineColor(obj) {
            return [0, 0, 0, 1];
          },
          getFillColor: function getFillColor(obj) {
            return [0, 0, 0, 1];
          },
          getPolygon: function getPolygon(o) {
            return o.geometry.coordinates;
          }
        })));
      }

      return layers;
    }
  }, {
    key: "shouldUpdateState",
    value: function shouldUpdateState(_ref2) {
      var _ref2$changeFlags = _ref2.changeFlags,
          stateChanged = _ref2$changeFlags.stateChanged,
          propsOrDataChanged = _ref2$changeFlags.propsOrDataChanged;
      return stateChanged || propsOrDataChanged;
    }
  }]);

  return SelectionLayer;
}(_core.CompositeLayer);

exports.default = SelectionLayer;
SelectionLayer.layerName = 'SelectionLayer';
SelectionLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXllcnMvc2VsZWN0aW9uLWxheWVyLmpzIl0sIm5hbWVzIjpbIlNFTEVDVElPTl9UWVBFIiwiTk9ORSIsIlJFQ1RBTkdMRSIsIlBPTFlHT04iLCJkZWZhdWx0UHJvcHMiLCJzZWxlY3Rpb25UeXBlIiwibGF5ZXJJZHMiLCJvblNlbGVjdCIsIkVNUFRZX0RBVEEiLCJ0eXBlIiwiZmVhdHVyZXMiLCJFWFBBTlNJT05fS00iLCJMQVlFUl9JRF9HRU9KU09OIiwiTEFZRVJfSURfQkxPQ0tFUiIsIlBBU1NfVEhST1VHSF9QUk9QUyIsIlNlbGVjdGlvbkxheWVyIiwiY29vcmRpbmF0ZXMiLCJwcm9wcyIsImNvbnRleHQiLCJ2aWV3cG9ydCIsInByb2plY3QiLCJ4MSIsInkxIiwieDIiLCJ5MiIsInBpY2tpbmdJbmZvcyIsImxheWVyTWFuYWdlciIsInBpY2tPYmplY3RzIiwidmlld3BvcnRzIiwieCIsIk1hdGgiLCJtaW4iLCJ5Iiwid2lkdGgiLCJhYnMiLCJoZWlnaHQiLCJtb3VzZVBvaW50cyIsIm1hcCIsImMiLCJhbGxYIiwibW91c2VQb2ludCIsImFsbFkiLCJtYXhYIiwibWF4IiwibWF4WSIsImxhbmRQb2ludHNQb2x5IiwiYmlnQnVmZmVyIiwiYmlnUG9seWdvbiIsImUiLCJjb25zb2xlIiwibG9nIiwic2V0U3RhdGUiLCJwZW5kaW5nUG9seWdvblNlbGVjdGlvbiIsImJsb2NrZXJJZCIsImlkIiwic2V0VGltZW91dCIsImZpbHRlciIsIml0ZW0iLCJsYXllciIsInN0YXRlIiwibW9kZSIsImluaGVyaXRlZFByb3BzIiwiZm9yRWFjaCIsInAiLCJ1bmRlZmluZWQiLCJsYXllcnMiLCJFZGl0YWJsZUdlb0pzb25MYXllciIsImdldFN1YkxheWVyUHJvcHMiLCJwaWNrYWJsZSIsInNlbGVjdGVkRmVhdHVyZUluZGV4ZXMiLCJkYXRhIiwib25FZGl0IiwidXBkYXRlZERhdGEiLCJlZGl0VHlwZSIsImdlb21ldHJ5IiwiX3NlbGVjdFJlY3RhbmdsZU9iamVjdHMiLCJfc2VsZWN0UG9seWdvbk9iamVjdHMiLCJwdXNoIiwiUG9seWdvbkxheWVyIiwic3Ryb2tlZCIsIm9wYWNpdHkiLCJnZXRMaW5lQ29sb3IiLCJvYmoiLCJnZXRGaWxsQ29sb3IiLCJnZXRQb2x5Z29uIiwibyIsImNoYW5nZUZsYWdzIiwic3RhdGVDaGFuZ2VkIiwicHJvcHNPckRhdGFDaGFuZ2VkIiwiQ29tcG9zaXRlTGF5ZXIiLCJsYXllck5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRU8sSUFBTUEsY0FBYyxHQUFHO0FBQzVCQyxFQUFBQSxJQUFJLEVBQUUsSUFEc0I7QUFFNUJDLEVBQUFBLFNBQVMsRUFBRSxXQUZpQjtBQUc1QkMsRUFBQUEsT0FBTyxFQUFFO0FBSG1CLENBQXZCOztBQU1QLElBQU1DLFlBQVksR0FBRztBQUNuQkMsRUFBQUEsYUFBYSxFQUFFTCxjQUFjLENBQUNFLFNBRFg7QUFFbkJJLEVBQUFBLFFBQVEsRUFBRSxFQUZTO0FBR25CQyxFQUFBQSxRQUFRLEVBQUUsb0JBQU0sQ0FBRTtBQUhDLENBQXJCO0FBTUEsSUFBTUMsVUFBVSxHQUFHO0FBQ2pCQyxFQUFBQSxJQUFJLEVBQUUsbUJBRFc7QUFFakJDLEVBQUFBLFFBQVEsRUFBRTtBQUZPLENBQW5CO0FBS0EsSUFBTUMsWUFBWSxHQUFHLEVBQXJCO0FBQ0EsSUFBTUMsZ0JBQWdCLEdBQUcsbUJBQXpCO0FBQ0EsSUFBTUMsZ0JBQWdCLEdBQUcsbUJBQXpCO0FBRUEsSUFBTUMsa0JBQWtCLEdBQUcsQ0FDekIsZ0JBRHlCLEVBRXpCLG9CQUZ5QixFQUd6QixvQkFIeUIsRUFJekIsa0JBSnlCLEVBS3pCLGdCQUx5QixFQU16QixrQkFOeUIsRUFPekIsc0JBUHlCLEVBUXpCLHNCQVJ5QixFQVN6QixtQkFUeUIsRUFVekIsY0FWeUIsRUFXekIsY0FYeUIsRUFZekIsV0Fa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RUQsYUFBT2lELE1BQVA7QUFDRDs7OzZDQUVnRjtBQUFBLG9DQUE3RHFCLFdBQTZEO0FBQUEsVUFBOUNDLFlBQThDLHFCQUE5Q0EsWUFBOEM7QUFBQSxVQUFoQ0Msa0JBQWdDLHFCQUFoQ0Esa0JBQWdDO0FBQy9FLGFBQU9ELFlBQVksSUFBSUMsa0JBQXZCO0FBQ0Q7Ozs7RUFuSXlDQyxvQjs7O0FBc0k1QzFFLGNBQWMsQ0FBQzJFLFNBQWYsR0FBMkIsZ0JBQTNCO0FBQ0EzRSxjQUFjLENBQUNYLFlBQWYsR0FBOEJBLFlBQTlCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuaW1wb3J0IHsgQ29tcG9zaXRlTGF5ZXIgfSBmcm9tICdAZGVjay5nbC9jb3JlJztcbmltcG9ydCB7IFBvbHlnb25MYXllciB9IGZyb20gJ0BkZWNrLmdsL2xheWVycyc7XG5pbXBvcnQgeyBwb2x5Z29uIH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5pbXBvcnQgdHVyZkJ1ZmZlciBmcm9tICdAdHVyZi9idWZmZXInO1xuaW1wb3J0IHR1cmZEaWZmZXJlbmNlIGZyb20gJ0B0dXJmL2RpZmZlcmVuY2UnO1xuXG5pbXBvcnQgRWRpdGFibGVHZW9Kc29uTGF5ZXIgZnJvbSAnLi9lZGl0YWJsZS1nZW9qc29uLWxheWVyJztcblxuZXhwb3J0IGNvbnN0IFNFTEVDVElPTl9UWVBFID0ge1xuICBOT05FOiBudWxsLFxuICBSRUNUQU5HTEU6ICdyZWN0YW5nbGUnLFxuICBQT0xZR09OOiAncG9seWdvbidcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgc2VsZWN0aW9uVHlwZTogU0VMRUNUSU9OX1RZUEUuUkVDVEFOR0xFLFxuICBsYXllcklkczogW10sXG4gIG9uU2VsZWN0OiAoKSA9PiB7fVxufTtcblxuY29uc3QgRU1QVFlfREFUQSA9IHtcbiAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgZmVhdHVyZXM6IFtdXG59O1xuXG5jb25zdCBFWFBBTlNJT05fS00gPSA1MDtcbmNvbnN0IExBWUVSX0lEX0dFT0pTT04gPSAnc2VsZWN0aW9uLWdlb2pzb24nO1xuY29uc3QgTEFZRVJfSURfQkxPQ0tFUiA9ICdzZWxlY3Rpb24tYmxvY2tlcic7XG5cbmNvbnN0IFBBU1NfVEhST1VHSF9QUk9QUyA9IFtcbiAgJ2xpbmVXaWR0aFNjYWxlJyxcbiAgJ2xpbmVXaWR0aE1pblBpeGVscycsXG4gICdsaW5lV2lkdGhNYXhQaXhlbHMnLFxuICAnbGluZUpvaW50Um91bmRlZCcsXG4gICdsaW5lTWl0ZXJMaW1pdCcsXG4gICdwb2ludFJhZGl1c1NjYWxlJyxcbiAgJ3BvaW50UmFkaXVzTWluUGl4ZWxzJyxcbiAgJ3BvaW50UmFkaXVzTWF4UGl4ZWxzJyxcbiAgJ2xpbmVEYXNoSnVzdGlmaWVkJyxcbiAgJ2dldExpbmVDb2xvcicsXG4gICdnZXRGaWxsQ29sb3InLFxuICAnZ2V0UmFkaXVzJyxcbiAgJ2dldExpbmVXaWR0aCcsXG4gICdnZXRMaW5lRGFzaEFycmF5JyxcbiAgJ2dldFRlbnRhdGl2ZUxpbmVEYXNoQXJyYXknLFxuICAnZ2V0VGVudGF0aXZlTGluZUNvbG9yJyxcbiAgJ2dldFRlbnRhdGl2ZUZpbGxDb2xvcicsXG4gICdnZXRUZW50YXRpdmVMaW5lV2lkdGgnXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3Rpb25MYXllciBleHRlbmRzIENvbXBvc2l0ZUxheWVyIHtcbiAgX3NlbGVjdFJlY3RhbmdsZU9iamVjdHMoY29vcmRpbmF0ZXM6IGFueSkge1xuICAgIGNvbnN0IHsgbGF5ZXJJZHMsIG9uU2VsZWN0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgW3gxLCB5MV0gPSB0aGlzLmNvbnRleHQudmlld3BvcnQucHJvamVjdChjb29yZGluYXRlc1swXVswXSk7XG4gICAgY29uc3QgW3gyLCB5Ml0gPSB0aGlzLmNvbnRleHQudmlld3BvcnQucHJvamVjdChjb29yZGluYXRlc1swXVsyXSk7XG5cbiAgICBjb25zdCBwaWNraW5nSW5mb3MgPSB0aGlzLmNvbnRleHQubGF5ZXJNYW5hZ2VyLnBpY2tPYmplY3RzKHtcbiAgICAgIHZpZXdwb3J0czogW3RoaXMuY29udGV4dC52aWV3cG9ydF0sXG4gICAgICB4OiBNYXRoLm1pbih4MSwgeDIpLFxuICAgICAgeTogTWF0aC5taW4oeTEsIHkyKSxcbiAgICAgIHdpZHRoOiBNYXRoLmFicyh4MiAtIHgxKSxcbiAgICAgIGhlaWdodDogTWF0aC5hYnMoeTIgLSB5MSksXG4gICAgICBsYXllcklkc1xuICAgIH0pO1xuXG4gICAgb25TZWxlY3QoeyBwaWNraW5nSW5mb3MgfSk7XG4gIH1cblxuICBfc2VsZWN0UG9seWdvbk9iamVjdHMoY29vcmRpbmF0ZXM6IGFueSkge1xuICAgIGNvbnN0IHsgbGF5ZXJJZHMsIG9uU2VsZWN0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG1vdXNlUG9pbnRzID0gY29vcmRpbmF0ZXNbMF0ubWFwKGMgPT4gdGhpcy5jb250ZXh0LnZpZXdwb3J0LnByb2plY3QoYykpO1xuXG4gICAgY29uc3QgYWxsWCA9IG1vdXNlUG9pbnRzLm1hcChtb3VzZVBvaW50ID0+IG1vdXNlUG9pbnRbMF0pO1xuICAgIGNvbnN0IGFsbFkgPSBtb3VzZVBvaW50cy5tYXAobW91c2VQb2ludCA9PiBtb3VzZVBvaW50WzFdKTtcbiAgICBjb25zdCB4ID0gTWF0aC5taW4oLi4uYWxsWCk7XG4gICAgY29uc3QgeSA9IE1hdGgubWluKC4uLmFsbFkpO1xuICAgIGNvbnN0IG1heFggPSBNYXRoLm1heCguLi5hbGxYKTtcbiAgICBjb25zdCBtYXhZID0gTWF0aC5tYXgoLi4uYWxsWSk7XG5cbiAgICAvLyBVc2UgYSBwb2x5Z29uIHRvIGhpZGUgdGhlIG91dHNpZGUsIGJlY2F1c2UgcGlja09iamVjdHMoKVxuICAgIC8vIGRvZXMgbm90IHN1cHBvcnQgcG9seWdvbnNcbiAgICBjb25zdCBsYW5kUG9pbnRzUG9seSA9IHBvbHlnb24oY29vcmRpbmF0ZXMpO1xuICAgIGNvbnN0IGJpZ0J1ZmZlciA9IHR1cmZCdWZmZXIobGFuZFBvaW50c1BvbHksIEVYUEFOU0lPTl9LTSk7XG4gICAgbGV0IGJpZ1BvbHlnb247XG4gICAgdHJ5IHtcbiAgICAgIC8vIHR1cmZEaWZmZXJlbmNlIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHBvbHlnb25cbiAgICAgIC8vIGludGVyc2VjdHMgd2l0aCBpdHNlbGYgKFRPRE86IGNoZWNrIGlmIHRydWUgaW4gYWxsIHZlcnNpb25zKVxuICAgICAgYmlnUG9seWdvbiA9IHR1cmZEaWZmZXJlbmNlKGJpZ0J1ZmZlciwgbGFuZFBvaW50c1BvbHkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGludmFsaWQgc2VsZWN0aW9uIHBvbHlnb25cbiAgICAgIGNvbnNvbGUubG9nKCd0dXJmRGlmZmVyZW5jZSgpIGVycm9yJywgZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBlbmRpbmdQb2x5Z29uU2VsZWN0aW9uOiB7XG4gICAgICAgIGJpZ1BvbHlnb25cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGJsb2NrZXJJZCA9IGAke3RoaXMucHJvcHMuaWR9LSR7TEFZRVJfSURfQkxPQ0tFUn1gO1xuXG4gICAgLy8gSEFDSywgZmluZCBhIGJldHRlciB3YXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IHBpY2tpbmdJbmZvcyA9IHRoaXMuY29udGV4dC5sYXllck1hbmFnZXIucGlja09iamVjdHMoe1xuICAgICAgICB2aWV3cG9ydHM6IFt0aGlzLmNvbnRleHQudmlld3BvcnRdLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB3aWR0aDogbWF4WCAtIHgsXG4gICAgICAgIGhlaWdodDogbWF4WSAtIHksXG4gICAgICAgIGxheWVySWRzOiBbYmxvY2tlcklkLCAuLi5sYXllcklkc11cbiAgICAgIH0pO1xuXG4gICAgICBvblNlbGVjdCh7XG4gICAgICAgIHBpY2tpbmdJbmZvczogcGlja2luZ0luZm9zLmZpbHRlcihpdGVtID0+IGl0ZW0ubGF5ZXIuaWQgIT09IHRoaXMucHJvcHMuaWQpXG4gICAgICB9KTtcbiAgICB9LCAyNTApO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIGNvbnN0IHsgcGVuZGluZ1BvbHlnb25TZWxlY3Rpb24gfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBtb2RlID1cbiAgICAgIHtcbiAgICAgICAgW1NFTEVDVElPTl9UWVBFLlJFQ1RBTkdMRV06ICdkcmF3UmVjdGFuZ2xlJyxcbiAgICAgICAgW1NFTEVDVElPTl9UWVBFLlBPTFlHT05dOiAnZHJhd1BvbHlnb24nXG4gICAgICB9W3RoaXMucHJvcHMuc2VsZWN0aW9uVHlwZV0gfHwgJ3ZpZXcnO1xuXG4gICAgY29uc3QgaW5oZXJpdGVkUHJvcHMgPSB7fTtcbiAgICBQQVNTX1RIUk9VR0hfUFJPUFMuZm9yRWFjaChwID0+IHtcbiAgICAgIGlmICh0aGlzLnByb3BzW3BdICE9PSB1bmRlZmluZWQpIGluaGVyaXRlZFByb3BzW3BdID0gdGhpcy5wcm9wc1twXTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGxheWVycyA9IFtcbiAgICAgIG5ldyBFZGl0YWJsZUdlb0pzb25MYXllcihcbiAgICAgICAgdGhpcy5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgICAgICBpZDogTEFZRVJfSURfR0VPSlNPTixcbiAgICAgICAgICBwaWNrYWJsZTogdHJ1ZSxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZUluZGV4ZXM6IFtdLFxuICAgICAgICAgIGRhdGE6IEVNUFRZX0RBVEEsXG4gICAgICAgICAgb25FZGl0OiAoeyB1cGRhdGVkRGF0YSwgZWRpdFR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVkaXRUeXBlID09PSAnYWRkRmVhdHVyZScpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBjb29yZGluYXRlcyB9ID0gdXBkYXRlZERhdGEuZmVhdHVyZXNbMF0uZ2VvbWV0cnk7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuc2VsZWN0aW9uVHlwZSA9PT0gU0VMRUNUSU9OX1RZUEUuUkVDVEFOR0xFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0UmVjdGFuZ2xlT2JqZWN0cyhjb29yZGluYXRlcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5zZWxlY3Rpb25UeXBlID09PSBTRUxFQ1RJT05fVFlQRS5QT0xZR09OKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0UG9seWdvbk9iamVjdHMoY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAuLi5pbmhlcml0ZWRQcm9wc1xuICAgICAgICB9KVxuICAgICAgKVxuICAgIF07XG5cbiAgICBpZiAocGVuZGluZ1BvbHlnb25TZWxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IHsgYmlnUG9seWdvbiB9ID0gcGVuZGluZ1BvbHlnb25TZWxlY3Rpb247XG4gICAgICBsYXllcnMucHVzaChcbiAgICAgICAgbmV3IFBvbHlnb25MYXllcihcbiAgICAgICAgICB0aGlzLmdldFN1YkxheWVyUHJvcHMoe1xuICAgICAgICAgICAgaWQ6IExBWUVSX0lEX0JMT0NLRVIsXG4gICAgICAgICAgICBwaWNrYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHN0cm9rZWQ6IGZhbHNlLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wLFxuICAgICAgICAgICAgZGF0YTogW2JpZ1BvbHlnb25dLFxuICAgICAgICAgICAgZ2V0TGluZUNvbG9yOiBvYmogPT4gWzAsIDAsIDAsIDFdLFxuICAgICAgICAgICAgZ2V0RmlsbENvbG9yOiBvYmogPT4gWzAsIDAsIDAsIDFdLFxuICAgICAgICAgICAgZ2V0UG9seWdvbjogbyA9PiBvLmdlb21ldHJ5LmNvb3JkaW5hdGVzXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgc2hvdWxkVXBkYXRlU3RhdGUoeyBjaGFuZ2VGbGFnczogeyBzdGF0ZUNoYW5nZWQsIHByb3BzT3JEYXRhQ2hhbmdlZCB9IH06IE9iamVjdCkge1xuICAgIHJldHVybiBzdGF0ZUNoYW5nZWQgfHwgcHJvcHNPckRhdGFDaGFuZ2VkO1xuICB9XG59XG5cblNlbGVjdGlvbkxheWVyLmxheWVyTmFtZSA9ICdTZWxlY3Rpb25MYXllcic7XG5TZWxlY3Rpb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=