"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SnappableHandler = void 0;

var _modeHandler = require("./mode-handler");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEFAULT_SNAP_PIXELS = 5;

var SnappableHandler =
/*#__PURE__*/
function (_ModeHandler) {
  _inherits(SnappableHandler, _ModeHandler);

  function SnappableHandler(handler) {
    var _this;

    _classCallCheck(this, SnappableHandler);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SnappableHandler).call(this));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_handler", void 0);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_editHandlePicks", void 0);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_startDragSnapHandlePosition", void 0);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "_isSnapped", void 0);

    _this._handler = handler;
    return _this;
  }

  _createClass(SnappableHandler, [{
    key: "setFeatureCollection",
    value: function setFeatureCollection(featureCollection) {
      this._handler.setFeatureCollection(featureCollection);
    }
  }, {
    key: "setModeConfig",
    value: function setModeConfig(modeConfig) {
      this._modeConfig = modeConfig;

      this._handler.setModeConfig(modeConfig);
    }
  }, {
    key: "setSelectedFeatureIndexes",
    value: function setSelectedFeatureIndexes(indexes) {
      this._handler.setSelectedFeatureIndexes(indexes);
    }
  }, {
    key: "setDeckGlContext",
    value: function setDeckGlContext(context) {
      _get(_getPrototypeOf(SnappableHandler.prototype), "setDeckGlContext", this).call(this, context);

      this._handler.setDeckGlContext(context);
    }
  }, {
    key: "_getSnappedMouseEvent",
    value: function _getSnappedMouseEvent(event, snapPoint) {
      return Object.assign({}, event, {
        groundCoords: snapPoint,
        screenCoords: this._context.viewport.project(snapPoint),
        pointerDownGroundCoords: this._startDragSnapHandlePosition
      });
    }
  }, {
    key: "_getEditHandleLayerId",
    value: function _getEditHandleLayerId() {
      // TODO: This is hacky, find a better way!
      var layers = this._context.layerManager.layers;
      var layer = layers.find(function (l) {
        return l.id.endsWith('-edit-handles');
      });
      return layer ? layer.id : '';
    }
  }, {
    key: "_getEditHandlePicks",
    value: function _getEditHandlePicks(event) {
      var screenCoords = event.screenCoords;

      var _ref = this._modeConfig || {},
          _ref$snapPixels = _ref.snapPixels,
          snapPixels = _ref$snapPixels === void 0 ? DEFAULT_SNAP_PIXELS : _ref$snapPixels;

      var picks = this._context.layerManager.pickObject({
        x: screenCoords[0],
        y: screenCoords[1],
        mode: 'query',
        layerIds: [this._getEditHandleLayerId()],
        radius: snapPixels,
        viewports: [this._context.viewport],
        depth: 2
      });

      var potentialSnapHandle = picks.find(function (pick) {
        return pick.object && pick.object.type === 'intermediate';
      });
      var handles = {
        potentialSnapHandle: potentialSnapHandle && potentialSnapHandle.object
      };
      var pickedHandle = (0, _modeHandler.getPickedEditHandle)(event.pointerDownPicks);

      if (pickedHandle) {
        return _objectSpread({}, handles, {
          pickedHandle: pickedHandle
        });
      }

      return handles;
    }
  }, {
    key: "_updatePickedHandlePosition",
    value: function _updatePickedHandlePosition(editAction) {
      var _ref2 = this._editHandlePicks || {},
          pickedHandle = _ref2.pickedHandle;

      if (pickedHandle && editAction) {
        var featureIndexes = editAction.featureIndexes,
            updatedData = editAction.updatedData;

        for (var i = 0; i < featureIndexes.length; i++) {
          var selectedIndex = featureIndexes[i];
          var updatedFeature = updatedData.features[selectedIndex];
          var positionIndexes = pickedHandle.positionIndexes,
              featureIndex = pickedHandle.featureIndex;

          if (selectedIndex >= 0 && featureIndex === selectedIndex) {
            var coordinates = updatedFeature.geometry.coordinates; // $FlowFixMe

            pickedHandle.position = positionIndexes.reduce(function (a, b) {
              return a[b];
            }, coordinates);
          }
        }
      }
    } // If layerIdsToSnapTo is present in modeConfig and is populated, this
    // method will return the features from the specified layers along with the features
    // that live in the current layer. Otherwise, this method will simply return the
    // features from the current layer

  }, {
    key: "_getFeaturesFromRelevantLayers",
    value: function _getFeaturesFromRelevantLayers() {
      var _this2 = this;

      var features = _toConsumableArray(this._handler.featureCollection.getObject().features);

      var _ref3 = this._modeConfig || {},
          layerIdsToSnapTo = _ref3.layerIdsToSnapTo;

      if (layerIdsToSnapTo && layerIdsToSnapTo.length) {
        var otherLayersToSnapTo = this._context.layerManager.layers.filter(function (layer) {
          var shouldPickFromLayer = layerIdsToSnapTo && layerIdsToSnapTo.includes(layer.id); // Filter out the current layer since the current layer's features are
          // already populated in the features array.

          return shouldPickFromLayer && layer.id !== _this2._layerId;
        });

        var featuresFromAdditionalLayers = otherLayersToSnapTo.map(function (otherLayer) {
          return otherLayer.props.data;
        }).reduce(function (a, b) {
          return _toConsumableArray(a).concat(_toConsumableArray(b));
        }, []);
        features.push.apply(features, _toConsumableArray(featuresFromAdditionalLayers));
      }

      return features;
    }
  }, {
    key: "_getNonPickedIntermediateHandles",
    value: function _getNonPickedIntermediateHandles() {
      var handles = [];

      var features = this._getFeaturesFromRelevantLayers();

      for (var i = 0; i < features.length; i++) {
        // Filter out the currently selected feature(s)
        var isCurrentIndexFeatureNotSelected = i < features.length && !this._handler.getSelectedFeatureIndexes().includes(i);

        if (isCurrentIndexFeatureNotSelected) {
          var geometry = features[i].geometry;
          handles.push.apply(handles, _toConsumableArray((0, _modeHandler.getEditHandlesForGeometry)(geometry, i, 'intermediate')));
        }
      }

      return handles;
    } // If no snap handle has been picked, only display the edit handles of the
    // selected feature. If a snap handle has been picked, display said snap handle
    // along with all snappable points on all non-selected features.

  }, {
    key: "getEditHandles",
    value: function getEditHandles(picks, groundCoords) {
      var _ref4 = this._modeConfig || {},
          enableSnapping = _ref4.enableSnapping;

      var handles = this._handler.getEditHandles(picks, groundCoords);

      if (!enableSnapping) return handles;

      var _ref5 = this._editHandlePicks || {},
          pickedHandle = _ref5.pickedHandle;

      if (pickedHandle) {
        handles.push.apply(handles, _toConsumableArray(this._getNonPickedIntermediateHandles()).concat([pickedHandle]));
        return handles;
      }

      var _this$_handler$featur = this._handler.featureCollection.getObject(),
          features = _this$_handler$featur.features;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._handler.getSelectedFeatureIndexes()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var index = _step.value;

          if (index < features.length) {
            var geometry = features[index].geometry;
            handles.push.apply(handles, _toConsumableArray((0, _modeHandler.getEditHandlesForGeometry)(geometry, index, 'snap')));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return handles.filter(Boolean);
    }
  }, {
    key: "_performSnapIfRequired",
    value: function _performSnapIfRequired() {
      if (this._isSnapped) return;

      var _ref6 = this._editHandlePicks || {},
          pickedHandle = _ref6.pickedHandle,
          potentialSnapHandle = _ref6.potentialSnapHandle;

      if (pickedHandle && potentialSnapHandle) {
        this._isSnapped = true;
      }
    } // Unsnapping only occurs after the user snaps two polygons but continues to drag the
    // cursor past the point of resistance.

  }, {
    key: "_performUnsnapIfRequired",
    value: function _performUnsnapIfRequired() {
      if (!this._isSnapped) return;

      var _ref7 = this._editHandlePicks || {},
          potentialSnapHandle = _ref7.potentialSnapHandle;

      if (!potentialSnapHandle) {
        this._isSnapped = false;
      }
    }
  }, {
    key: "_getSnapAwareEvent",
    value: function _getSnapAwareEvent(event) {
      var _ref8 = this._editHandlePicks || {},
          potentialSnapHandle = _ref8.potentialSnapHandle;

      return potentialSnapHandle && potentialSnapHandle.position ? this._getSnappedMouseEvent(event, potentialSnapHandle.position) : event;
    }
  }, {
    key: "handleStartDragging",
    value: function handleStartDragging(event) {
      this._startDragSnapHandlePosition = ((0, _modeHandler.getPickedEditHandle)(event.picks) || {}).position;
      return this._handler.handleStartDragging(event);
    }
  }, {
    key: "handleStopDragging",
    value: function handleStopDragging(event) {
      var modeActionSummary = this._handler.handleStopDragging(this._getSnapAwareEvent(event));

      this._editHandlePicks = null;
      this._isSnapped = false;
      return modeActionSummary;
    }
  }, {
    key: "getCursor",
    value: function getCursor(event) {
      return this._handler.getCursor(event);
    }
  }, {
    key: "handlePointerMove",
    value: function handlePointerMove(event) {
      var _ref9 = this._handler.getModeConfig() || {},
          enableSnapping = _ref9.enableSnapping;

      if (enableSnapping) {
        this._editHandlePicks = this._getEditHandlePicks(event);

        if (this._editHandlePicks) {
          this._performSnapIfRequired();

          this._performUnsnapIfRequired();
        }
      }

      var modeActionSummary = this._handler.handlePointerMove(this._getSnapAwareEvent(event));

      var editAction = modeActionSummary.editAction;

      if (editAction) {
        this._updatePickedHandlePosition(editAction);
      }

      return modeActionSummary;
    }
  }]);

  return SnappableHandler;
}(_modeHandler.ModeHandler);

exports.SnappableHandler = SnappableHandler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb2RlLWhhbmRsZXJzL3NuYXBwYWJsZS1oYW5kbGVyLmpzIl0sIm5hbWVzIjpbIkRFRkFVTFRfU05BUF9QSVhFTFMiLCJTbmFwcGFibGVIYW5kbGVyIiwiaGFuZGxlciIsIl9oYW5kbGVyIiwiZmVhdHVyZUNvbGxlY3Rpb24iLCJzZXRGZWF0dXJlQ29sbGVjdGlvbiIsIm1vZGVDb25maWciLCJfbW9kZUNvbmZpZyIsInNldE1vZGVDb25maWciLCJpbmRleGVzIiwic2V0U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcyIsImNvbnRleHQiLCJzZXREZWNrR2xDb250ZXh0IiwiZXZlbnQiLCJzbmFwUG9pbnQiLCJPYmplY3QiLCJhc3NpZ24iLCJncm91bmRDb29yZHMiLCJzY3JlZW5Db29yZHMiLCJfY29udGV4dCIsInZpZXdwb3J0IiwicHJvamVjdCIsInBvaW50ZXJEb3duR3JvdW5kQ29vcmRzIiwiX3N0YXJ0RHJhZ1NuYXBIYW5kbGVQb3NpdGlvbiIsImxheWVycyIsImxheWVyTWFuYWdlciIsImxheWVyIiwiZmluZCIsImwiLCJpZCIsImVuZHNXaXRoIiwic25hcFBpeGVscyIsInBpY2tzIiwicGlja09iamVjdCIsIngiLCJ5IiwibW9kZSIsImxheWVySWRzIiwiX2dldEVkaXRIYW5kbGVMYXllcklkIiwicmFkaXVzIiwidmlld3BvcnRzIiwiZGVwdGgiLCJwb3RlbnRpYWxTbmFwSGFuZGxlIiwicGljayIsIm9iamVjdCIsInR5cGUiLCJoYW5kbGVzIiwicGlja2VkSGFuZGxlIiwicG9pbnRlckRvd25QaWNrcyIsImVkaXRBY3Rpb24iLCJfZWRpdEhhbmRsZVBpY2tzIiwiZmVhdHVyZUluZGV4ZXMiLCJ1cGRhdGVkRGF0YSIsImkiLCJsZW5ndGgiLCJzZWxlY3RlZEluZGV4IiwidXBkYXRlZEZlYXR1cmUiLCJmZWF0dXJlcyIsInBvc2l0aW9uSW5kZXhlcyIsImZlYXR1cmVJbmRleCIsImNvb3JkaW5hdGVzIiwiZ2VvbWV0cnkiLCJwb3NpdGlvbiIsInJlZHVjZSIsImEiLCJiIiwiZ2V0T2JqZWN0IiwibGF5ZXJJZHNUb1NuYXBUbyIsIm90aGVyTGF5ZXJzVG9TbmFwVG8iLCJmaWx0ZXIiLCJzaG91bGRQaWNrRnJvbUxheWVyIiwiaW5jbHVkZXMiLCJfbGF5ZXJJZCIsImZlYXR1cmVzRnJvbUFkZGl0aW9uYWxMYXllcnMiLCJtYXAiLCJvdGhlckxheWVyIiwicHJvcHMiLCJkYXRhIiwicHVzaCIsIl9nZXRGZWF0dXJlc0Zyb21SZWxldmFudExheWVycyIsImlzQ3VycmVudEluZGV4RmVhdHVyZU5vdFNlbGVjdGVkIiwiZ2V0U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcyIsImVuYWJsZVNuYXBwaW5nIiwiZ2V0RWRpdEhhbmRsZXMiLCJfZ2V0Tm9uUGlja2VkSW50ZXJtZWRpYXRlSGFuZGxlcyIsImluZGV4IiwiQm9vbGVhbiIsIl9pc1NuYXBwZWQiLCJfZ2V0U25hcHBlZE1vdXNlRXZlbnQiLCJoYW5kbGVTdGFydERyYWdnaW5nIiwibW9kZUFjdGlvblN1bW1hcnkiLCJoYW5kbGVTdG9wRHJhZ2dpbmciLCJfZ2V0U25hcEF3YXJlRXZlbnQiLCJnZXRDdXJzb3IiLCJnZXRNb2RlQ29uZmlnIiwiX2dldEVkaXRIYW5kbGVQaWNrcyIsIl9wZXJmb3JtU25hcElmUmVxdWlyZWQiLCJfcGVyZm9ybVVuc25hcElmUmVxdWlyZWQiLCJoYW5kbGVQb2ludGVyTW92ZSIsIl91cGRhdGVQaWNrZWRIYW5kbGVQb3NpdGlvbiIsIk1vZGVIYW5kbGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLG1CQUFtQixHQUFHLENBQTVCOztJQUlhQyxnQjs7Ozs7QUFNWCw0QkFBWUMsT0FBWixFQUFrQztBQUFBOztBQUFBOztBQUNoQzs7QUFEZ0M7O0FBQUE7O0FBQUE7O0FBQUE7O0FBRWhDLFVBQUtDLFFBQUwsR0FBZ0JELE9BQWhCO0FBRmdDO0FBR2pDOzs7O3lDQUVvQkUsaUIsRUFBNEM7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ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB0eXBlIHsgRmVhdHVyZUNvbGxlY3Rpb24sIFBvc2l0aW9uIH0gZnJvbSAnLi4vZ2VvanNvbi10eXBlcy5qcyc7XG5pbXBvcnQgdHlwZSB7IFBvaW50ZXJNb3ZlRXZlbnQsIFN0YXJ0RHJhZ2dpbmdFdmVudCwgU3RvcERyYWdnaW5nRXZlbnQgfSBmcm9tICcuLi9ldmVudC10eXBlcy5qcyc7XG5pbXBvcnQgdHlwZSB7IEVkaXRIYW5kbGUsIEVkaXRBY3Rpb24gfSBmcm9tICcuL21vZGUtaGFuZGxlci5qcyc7XG5pbXBvcnQgeyBNb2RlSGFuZGxlciwgZ2V0UGlja2VkRWRpdEhhbmRsZSwgZ2V0RWRpdEhhbmRsZXNGb3JHZW9tZXRyeSB9IGZyb20gJy4vbW9kZS1oYW5kbGVyJztcblxuY29uc3QgREVGQVVMVF9TTkFQX1BJWEVMUyA9IDU7XG5cbnR5cGUgSGFuZGxlUGlja3MgPSB7IHBpY2tlZEhhbmRsZT86IEVkaXRIYW5kbGUsIHBvdGVudGlhbFNuYXBIYW5kbGU/OiBFZGl0SGFuZGxlIH07XG5cbmV4cG9ydCBjbGFzcyBTbmFwcGFibGVIYW5kbGVyIGV4dGVuZHMgTW9kZUhhbmRsZXIge1xuICBfaGFuZGxlcjogTW9kZUhhbmRsZXI7XG4gIF9lZGl0SGFuZGxlUGlja3M6ID9IYW5kbGVQaWNrcztcbiAgX3N0YXJ0RHJhZ1NuYXBIYW5kbGVQb3NpdGlvbjogUG9zaXRpb247XG4gIF9pc1NuYXBwZWQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoaGFuZGxlcjogTW9kZUhhbmRsZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2hhbmRsZXIgPSBoYW5kbGVyO1xuICB9XG5cbiAgc2V0RmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZUNvbGxlY3Rpb246IEZlYXR1cmVDb2xsZWN0aW9uKTogdm9pZCB7XG4gICAgdGhpcy5faGFuZGxlci5zZXRGZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlQ29sbGVjdGlvbik7XG4gIH1cblxuICBzZXRNb2RlQ29uZmlnKG1vZGVDb25maWc6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX21vZGVDb25maWcgPSBtb2RlQ29uZmlnO1xuICAgIHRoaXMuX2hhbmRsZXIuc2V0TW9kZUNvbmZpZyhtb2RlQ29uZmlnKTtcbiAgfVxuXG4gIHNldFNlbGVjdGVkRmVhdHVyZUluZGV4ZXMoaW5kZXhlczogbnVtYmVyW10pOiB2b2lkIHtcbiAgICB0aGlzLl9oYW5kbGVyLnNldFNlbGVjdGVkRmVhdHVyZUluZGV4ZXMoaW5kZXhlcyk7XG4gIH1cblxuICBzZXREZWNrR2xDb250ZXh0KGNvbnRleHQ6IE9iamVjdCkge1xuICAgIHN1cGVyLnNldERlY2tHbENvbnRleHQoY29udGV4dCk7XG4gICAgdGhpcy5faGFuZGxlci5zZXREZWNrR2xDb250ZXh0KGNvbnRleHQpO1xuICB9XG5cbiAgX2dldFNuYXBwZWRNb3VzZUV2ZW50KGV2ZW50OiBPYmplY3QsIHNuYXBQb2ludDogUG9zaXRpb24pOiBQb2ludGVyTW92ZUV2ZW50IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQsIHtcbiAgICAgIGdyb3VuZENvb3Jkczogc25hcFBvaW50LFxuICAgICAgc2NyZWVuQ29vcmRzOiB0aGlzLl9jb250ZXh0LnZpZXdwb3J0LnByb2plY3Qoc25hcFBvaW50KSxcbiAgICAgIHBvaW50ZXJEb3duR3JvdW5kQ29vcmRzOiB0aGlzLl9zdGFydERyYWdTbmFwSGFuZGxlUG9zaXRpb25cbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRFZGl0SGFuZGxlTGF5ZXJJZCgpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGhhY2t5LCBmaW5kIGEgYmV0dGVyIHdheSFcbiAgICBjb25zdCB7IGxheWVycyB9ID0gdGhpcy5fY29udGV4dC5sYXllck1hbmFnZXI7XG4gICAgY29uc3QgbGF5ZXIgPSBsYXllcnMuZmluZChsID0+IGwuaWQuZW5kc1dpdGgoJy1lZGl0LWhhbmRsZXMnKSk7XG4gICAgcmV0dXJuIGxheWVyID8gbGF5ZXIuaWQgOiAnJztcbiAgfVxuXG4gIF9nZXRFZGl0SGFuZGxlUGlja3MoZXZlbnQ6IFBvaW50ZXJNb3ZlRXZlbnQpOiBIYW5kbGVQaWNrcyB7XG4gICAgY29uc3QgeyBzY3JlZW5Db29yZHMgfSA9IGV2ZW50O1xuICAgIGNvbnN0IHsgc25hcFBpeGVscyA9IERFRkFVTFRfU05BUF9QSVhFTFMgfSA9IHRoaXMuX21vZGVDb25maWcgfHwge307XG5cbiAgICBjb25zdCBwaWNrcyA9IHRoaXMuX2NvbnRleHQubGF5ZXJNYW5hZ2VyLnBpY2tPYmplY3Qoe1xuICAgICAgeDogc2NyZWVuQ29vcmRzWzBdLFxuICAgICAgeTogc2NyZWVuQ29vcmRzWzFdLFxuICAgICAgbW9kZTogJ3F1ZXJ5JyxcbiAgICAgIGxheWVySWRzOiBbdGhpcy5fZ2V0RWRpdEhhbmRsZUxheWVySWQoKV0sXG4gICAgICByYWRpdXM6IHNuYXBQaXhlbHMsXG4gICAgICB2aWV3cG9ydHM6IFt0aGlzLl9jb250ZXh0LnZpZXdwb3J0XSxcbiAgICAgIGRlcHRoOiAyXG4gICAgfSk7XG5cbiAgICBjb25zdCBwb3RlbnRpYWxTbmFwSGFuZGxlID0gcGlja3MuZmluZChcbiAgICAgIHBpY2sgPT4gcGljay5vYmplY3QgJiYgcGljay5vYmplY3QudHlwZSA9PT0gJ2ludGVybWVkaWF0ZSdcbiAgICApO1xuICAgIGNvbnN0IGhhbmRsZXMgPSB7IHBvdGVudGlhbFNuYXBIYW5kbGU6IHBvdGVudGlhbFNuYXBIYW5kbGUgJiYgcG90ZW50aWFsU25hcEhhbmRsZS5vYmplY3QgfTtcblxuICAgIGNvbnN0IHBpY2tlZEhhbmRsZSA9IGdldFBpY2tlZEVkaXRIYW5kbGUoZXZlbnQucG9pbnRlckRvd25QaWNrcyk7XG4gICAgaWYgKHBpY2tlZEhhbmRsZSkge1xuICAgICAgcmV0dXJuIHsgLi4uaGFuZGxlcywgcGlja2VkSGFuZGxlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZXM7XG4gIH1cblxuICBfdXBkYXRlUGlja2VkSGFuZGxlUG9zaXRpb24oZWRpdEFjdGlvbjogRWRpdEFjdGlvbikge1xuICAgIGNvbnN0IHsgcGlja2VkSGFuZGxlIH0gPSB0aGlzLl9lZGl0SGFuZGxlUGlja3MgfHwge307XG5cbiAgICBpZiAocGlja2VkSGFuZGxlICYmIGVkaXRBY3Rpb24pIHtcbiAgICAgIGNvbnN0IHsgZmVhdHVyZUluZGV4ZXMsIHVwZGF0ZWREYXRhIH0gPSBlZGl0QWN0aW9uO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXR1cmVJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBmZWF0dXJlSW5kZXhlc1tpXTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZlYXR1cmUgPSB1cGRhdGVkRGF0YS5mZWF0dXJlc1tzZWxlY3RlZEluZGV4XTtcblxuICAgICAgICBjb25zdCB7IHBvc2l0aW9uSW5kZXhlcywgZmVhdHVyZUluZGV4IH0gPSBwaWNrZWRIYW5kbGU7XG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ID49IDAgJiYgZmVhdHVyZUluZGV4ID09PSBzZWxlY3RlZEluZGV4KSB7XG4gICAgICAgICAgY29uc3QgeyBjb29yZGluYXRlcyB9ID0gdXBkYXRlZEZlYXR1cmUuZ2VvbWV0cnk7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICAgIHBpY2tlZEhhbmRsZS5wb3NpdGlvbiA9IHBvc2l0aW9uSW5kZXhlcy5yZWR1Y2UoXG4gICAgICAgICAgICAoYTogYW55W10sIGI6IG51bWJlcikgPT4gYVtiXSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIGxheWVySWRzVG9TbmFwVG8gaXMgcHJlc2VudCBpbiBtb2RlQ29uZmlnIGFuZCBpcyBwb3B1bGF0ZWQsIHRoaXNcbiAgLy8gbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBmZWF0dXJlcyBmcm9tIHRoZSBzcGVjaWZpZWQgbGF5ZXJzIGFsb25nIHdpdGggdGhlIGZlYXR1cmVzXG4gIC8vIHRoYXQgbGl2ZSBpbiB0aGUgY3VycmVudCBsYXllci4gT3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCB3aWxsIHNpbXBseSByZXR1cm4gdGhlXG4gIC8vIGZlYXR1cmVzIGZyb20gdGhlIGN1cnJlbnQgbGF5ZXJcbiAgX2dldEZlYXR1cmVzRnJvbVJlbGV2YW50TGF5ZXJzKCk6IE9iamVjdFtdIHtcbiAgICBjb25zdCBmZWF0dXJlcyA9IFsuLi50aGlzLl9oYW5kbGVyLmZlYXR1cmVDb2xsZWN0aW9uLmdldE9iamVjdCgpLmZlYXR1cmVzXTtcbiAgICBjb25zdCB7IGxheWVySWRzVG9TbmFwVG8gfSA9IHRoaXMuX21vZGVDb25maWcgfHwge307XG5cbiAgICBpZiAobGF5ZXJJZHNUb1NuYXBUbyAmJiBsYXllcklkc1RvU25hcFRvLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb3RoZXJMYXllcnNUb1NuYXBUbyA9IHRoaXMuX2NvbnRleHQubGF5ZXJNYW5hZ2VyLmxheWVycy5maWx0ZXIobGF5ZXIgPT4ge1xuICAgICAgICBjb25zdCBzaG91bGRQaWNrRnJvbUxheWVyID0gbGF5ZXJJZHNUb1NuYXBUbyAmJiBsYXllcklkc1RvU25hcFRvLmluY2x1ZGVzKGxheWVyLmlkKTtcblxuICAgICAgICAvLyBGaWx0ZXIgb3V0IHRoZSBjdXJyZW50IGxheWVyIHNpbmNlIHRoZSBjdXJyZW50IGxheWVyJ3MgZmVhdHVyZXMgYXJlXG4gICAgICAgIC8vIGFscmVhZHkgcG9wdWxhdGVkIGluIHRoZSBmZWF0dXJlcyBhcnJheS5cbiAgICAgICAgcmV0dXJuIHNob3VsZFBpY2tGcm9tTGF5ZXIgJiYgbGF5ZXIuaWQgIT09IHRoaXMuX2xheWVySWQ7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZmVhdHVyZXNGcm9tQWRkaXRpb25hbExheWVycyA9IG90aGVyTGF5ZXJzVG9TbmFwVG9cbiAgICAgICAgLm1hcChvdGhlckxheWVyID0+IG90aGVyTGF5ZXIucHJvcHMuZGF0YSlcbiAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gWy4uLmEsIC4uLmJdLCBbXSk7XG5cbiAgICAgIGZlYXR1cmVzLnB1c2goLi4uZmVhdHVyZXNGcm9tQWRkaXRpb25hbExheWVycyk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIF9nZXROb25QaWNrZWRJbnRlcm1lZGlhdGVIYW5kbGVzKCk6IEVkaXRIYW5kbGVbXSB7XG4gICAgY29uc3QgaGFuZGxlcyA9IFtdO1xuICAgIGNvbnN0IGZlYXR1cmVzID0gdGhpcy5fZ2V0RmVhdHVyZXNGcm9tUmVsZXZhbnRMYXllcnMoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmZWF0dXJlKHMpXG4gICAgICBjb25zdCBpc0N1cnJlbnRJbmRleEZlYXR1cmVOb3RTZWxlY3RlZCA9XG4gICAgICAgIGkgPCBmZWF0dXJlcy5sZW5ndGggJiYgIXRoaXMuX2hhbmRsZXIuZ2V0U2VsZWN0ZWRGZWF0dXJlSW5kZXhlcygpLmluY2x1ZGVzKGkpO1xuXG4gICAgICBpZiAoaXNDdXJyZW50SW5kZXhGZWF0dXJlTm90U2VsZWN0ZWQpIHtcbiAgICAgICAgY29uc3QgeyBnZW9tZXRyeSB9ID0gZmVhdHVyZXNbaV07XG4gICAgICAgIGhhbmRsZXMucHVzaCguLi5nZXRFZGl0SGFuZGxlc0Zvckdlb21ldHJ5KGdlb21ldHJ5LCBpLCAnaW50ZXJtZWRpYXRlJykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlcztcbiAgfVxuXG4gIC8vIElmIG5vIHNuYXAgaGFuZGxlIGhhcyBiZWVuIHBpY2tlZCwgb25seSBkaXNwbGF5IHRoZSBlZGl0IGhhbmRsZXMgb2YgdGhlXG4gIC8vIHNlbGVjdGVkIGZlYXR1cmUuIElmIGEgc25hcCBoYW5kbGUgaGFzIGJlZW4gcGlja2VkLCBkaXNwbGF5IHNhaWQgc25hcCBoYW5kbGVcbiAgLy8gYWxvbmcgd2l0aCBhbGwgc25hcHBhYmxlIHBvaW50cyBvbiBhbGwgbm9uLXNlbGVjdGVkIGZlYXR1cmVzLlxuICBnZXRFZGl0SGFuZGxlcyhwaWNrcz86IEFycmF5PE9iamVjdD4sIGdyb3VuZENvb3Jkcz86IFBvc2l0aW9uKTogYW55W10ge1xuICAgIGNvbnN0IHsgZW5hYmxlU25hcHBpbmcgfSA9IHRoaXMuX21vZGVDb25maWcgfHwge307XG4gICAgY29uc3QgaGFuZGxlcyA9IHRoaXMuX2hhbmRsZXIuZ2V0RWRpdEhhbmRsZXMocGlja3MsIGdyb3VuZENvb3Jkcyk7XG5cbiAgICBpZiAoIWVuYWJsZVNuYXBwaW5nKSByZXR1cm4gaGFuZGxlcztcbiAgICBjb25zdCB7IHBpY2tlZEhhbmRsZSB9ID0gdGhpcy5fZWRpdEhhbmRsZVBpY2tzIHx8IHt9O1xuXG4gICAgaWYgKHBpY2tlZEhhbmRsZSkge1xuICAgICAgaGFuZGxlcy5wdXNoKC4uLnRoaXMuX2dldE5vblBpY2tlZEludGVybWVkaWF0ZUhhbmRsZXMoKSwgcGlja2VkSGFuZGxlKTtcbiAgICAgIHJldHVybiBoYW5kbGVzO1xuICAgIH1cblxuICAgIGNvbnN0IHsgZmVhdHVyZXMgfSA9IHRoaXMuX2hhbmRsZXIuZmVhdHVyZUNvbGxlY3Rpb24uZ2V0T2JqZWN0KCk7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiB0aGlzLl9oYW5kbGVyLmdldFNlbGVjdGVkRmVhdHVyZUluZGV4ZXMoKSkge1xuICAgICAgaWYgKGluZGV4IDwgZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VvbWV0cnkgfSA9IGZlYXR1cmVzW2luZGV4XTtcbiAgICAgICAgaGFuZGxlcy5wdXNoKC4uLmdldEVkaXRIYW5kbGVzRm9yR2VvbWV0cnkoZ2VvbWV0cnksIGluZGV4LCAnc25hcCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlcy5maWx0ZXIoQm9vbGVhbik7XG4gIH1cblxuICBfcGVyZm9ybVNuYXBJZlJlcXVpcmVkKCkge1xuICAgIGlmICh0aGlzLl9pc1NuYXBwZWQpIHJldHVybjtcbiAgICBjb25zdCB7IHBpY2tlZEhhbmRsZSwgcG90ZW50aWFsU25hcEhhbmRsZSB9ID0gdGhpcy5fZWRpdEhhbmRsZVBpY2tzIHx8IHt9O1xuICAgIGlmIChwaWNrZWRIYW5kbGUgJiYgcG90ZW50aWFsU25hcEhhbmRsZSkge1xuICAgICAgdGhpcy5faXNTbmFwcGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBVbnNuYXBwaW5nIG9ubHkgb2NjdXJzIGFmdGVyIHRoZSB1c2VyIHNuYXBzIHR3byBwb2x5Z29ucyBidXQgY29udGludWVzIHRvIGRyYWcgdGhlXG4gIC8vIGN1cnNvciBwYXN0IHRoZSBwb2ludCBvZiByZXNpc3RhbmNlLlxuICBfcGVyZm9ybVVuc25hcElmUmVxdWlyZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1NuYXBwZWQpIHJldHVybjtcblxuICAgIGNvbnN0IHsgcG90ZW50aWFsU25hcEhhbmRsZSB9ID0gdGhpcy5fZWRpdEhhbmRsZVBpY2tzIHx8IHt9O1xuICAgIGlmICghcG90ZW50aWFsU25hcEhhbmRsZSkge1xuICAgICAgdGhpcy5faXNTbmFwcGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgX2dldFNuYXBBd2FyZUV2ZW50KGV2ZW50OiBPYmplY3QpOiBPYmplY3Qge1xuICAgIGNvbnN0IHsgcG90ZW50aWFsU25hcEhhbmRsZSB9ID0gdGhpcy5fZWRpdEhhbmRsZVBpY2tzIHx8IHt9O1xuXG4gICAgcmV0dXJuIHBvdGVudGlhbFNuYXBIYW5kbGUgJiYgcG90ZW50aWFsU25hcEhhbmRsZS5wb3NpdGlvblxuICAgICAgPyB0aGlzLl9nZXRTbmFwcGVkTW91c2VFdmVudChldmVudCwgcG90ZW50aWFsU25hcEhhbmRsZS5wb3NpdGlvbilcbiAgICAgIDogZXZlbnQ7XG4gIH1cblxuICBoYW5kbGVTdGFydERyYWdnaW5nKGV2ZW50OiBTdGFydERyYWdnaW5nRXZlbnQpOiA/RWRpdEFjdGlvbiB7XG4gICAgdGhpcy5fc3RhcnREcmFnU25hcEhhbmRsZVBvc2l0aW9uID0gKGdldFBpY2tlZEVkaXRIYW5kbGUoZXZlbnQucGlja3MpIHx8IHt9KS5wb3NpdGlvbjtcbiAgICByZXR1cm4gdGhpcy5faGFuZGxlci5oYW5kbGVTdGFydERyYWdnaW5nKGV2ZW50KTtcbiAgfVxuXG4gIGhhbmRsZVN0b3BEcmFnZ2luZyhldmVudDogU3RvcERyYWdnaW5nRXZlbnQpOiA/RWRpdEFjdGlvbiB7XG4gICAgY29uc3QgbW9kZUFjdGlvblN1bW1hcnkgPSB0aGlzLl9oYW5kbGVyLmhhbmRsZVN0b3BEcmFnZ2luZyh0aGlzLl9nZXRTbmFwQXdhcmVFdmVudChldmVudCkpO1xuXG4gICAgdGhpcy5fZWRpdEhhbmRsZVBpY2tzID0gbnVsbDtcbiAgICB0aGlzLl9pc1NuYXBwZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbW9kZUFjdGlvblN1bW1hcnk7XG4gIH1cblxuICBnZXRDdXJzb3IoZXZlbnQ6IHsgaXNEcmFnZ2luZzogYm9vbGVhbiB9KTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faGFuZGxlci5nZXRDdXJzb3IoZXZlbnQpO1xuICB9XG5cbiAgaGFuZGxlUG9pbnRlck1vdmUoZXZlbnQ6IFBvaW50ZXJNb3ZlRXZlbnQpOiB7IGVkaXRBY3Rpb246ID9FZGl0QWN0aW9uLCBjYW5jZWxNYXBQYW46IGJvb2xlYW4gfSB7XG4gICAgY29uc3QgeyBlbmFibGVTbmFwcGluZyB9ID0gdGhpcy5faGFuZGxlci5nZXRNb2RlQ29uZmlnKCkgfHwge307XG5cbiAgICBpZiAoZW5hYmxlU25hcHBpbmcpIHtcbiAgICAgIHRoaXMuX2VkaXRIYW5kbGVQaWNrcyA9IHRoaXMuX2dldEVkaXRIYW5kbGVQaWNrcyhldmVudCk7XG4gICAgICBpZiAodGhpcy5fZWRpdEhhbmRsZVBpY2tzKSB7XG4gICAgICAgIHRoaXMuX3BlcmZvcm1TbmFwSWZSZXF1aXJlZCgpO1xuICAgICAgICB0aGlzLl9wZXJmb3JtVW5zbmFwSWZSZXF1aXJlZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1vZGVBY3Rpb25TdW1tYXJ5ID0gdGhpcy5faGFuZGxlci5oYW5kbGVQb2ludGVyTW92ZSh0aGlzLl9nZXRTbmFwQXdhcmVFdmVudChldmVudCkpO1xuICAgIGNvbnN0IHsgZWRpdEFjdGlvbiB9ID0gbW9kZUFjdGlvblN1bW1hcnk7XG4gICAgaWYgKGVkaXRBY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlZEhhbmRsZVBvc2l0aW9uKGVkaXRBY3Rpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlQWN0aW9uU3VtbWFyeTtcbiAgfVxufVxuIl19