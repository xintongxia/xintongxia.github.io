"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SELECTION_TYPE = void 0;

var _layers = require("@deck.gl/layers");

var _helpers = require("@turf/helpers");

var _bbox = _interopRequireDefault(require("@turf/bbox"));

var _bboxPolygon = _interopRequireDefault(require("@turf/bbox-polygon"));

var _buffer = _interopRequireDefault(require("@turf/buffer"));

var _difference = _interopRequireDefault(require("@turf/difference"));

var _distance = _interopRequireDefault(require("@turf/distance"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var POLYGON_LINE_COLOR = [0, 255, 0, 255];
var POLYGON_FILL_COLOR = [255, 255, 255, 90];
var POLYGON_LINE_WIDTH = 2;
var POLYGON_DASHES = [20, 20];
var POLYGON_THRESHOLD = 0.01;
var EXPANSION_KM = 10;
var LAYER_ID_VIEW = 'DeckDrawerView';
var LAYER_ID_PICK = 'DeckDrawerPick';
var SELECTION_TYPE = {
  NONE: null,
  RECTANGLE: 'rectangle',
  POLYGON: 'polygon'
};
exports.SELECTION_TYPE = SELECTION_TYPE;

var DeckDrawer =
/*#__PURE__*/
function () {
  function DeckDrawer(nebula) {
    _classCallCheck(this, DeckDrawer);

    _defineProperty(this, "nebula", void 0);

    _defineProperty(this, "usePolygon", void 0);

    _defineProperty(this, "validPolygon", void 0);

    _defineProperty(this, "landPoints", void 0);

    _defineProperty(this, "mousePoints", void 0);

    this.nebula = nebula;
    this.usePolygon = false;
    this.landPoints = [];
    this.mousePoints = [];
  }

  _createClass(DeckDrawer, [{
    key: "_getLayerIds",
    value: function _getLayerIds() {
      // TODO: sort by mouse priority
      return this.nebula.deckgl.props.layers.filter(function (l) {
        return l && l.props && l.props.nebulaLayer && l.props.nebulaLayer.enableSelection;
      }).map(function (l) {
        return l.id;
      });
    }
  }, {
    key: "_selectFromPickingInfos",
    value: function _selectFromPickingInfos(pickingInfos) {
      var objects = pickingInfos.map(function (_ref) {
        var layer = _ref.layer,
            index = _ref.index,
            object = _ref.object;
        return object.original || layer.props.nebulaLayer.deckCache.originals[index];
      });
      this.nebula.props.onSelection(objects);
    }
  }, {
    key: "_getBoundingBox",
    value: function _getBoundingBox() {
      var mousePoints = this.mousePoints;
      var allX = mousePoints.map(function (mousePoint) {
        return mousePoint[0];
      });
      var allY = mousePoints.map(function (mousePoint) {
        return mousePoint[1];
      });
      var x = Math.min.apply(Math, _toConsumableArray(allX));
      var y = Math.min.apply(Math, _toConsumableArray(allY));
      var maxX = Math.max.apply(Math, _toConsumableArray(allX));
      var maxY = Math.max.apply(Math, _toConsumableArray(allY));
      return {
        x: x,
        y: y,
        width: maxX - x,
        height: maxY - y
      };
    }
  }, {
    key: "_selectRectangleObjects",
    value: function _selectRectangleObjects() {
      if (this.landPoints.length !== 2) return;

      var _this$mousePoints$ = _slicedToArray(this.mousePoints[0], 2),
          x1 = _this$mousePoints$[0],
          y1 = _this$mousePoints$[1];

      var _this$mousePoints$2 = _slicedToArray(this.mousePoints[1], 2),
          x2 = _this$mousePoints$2[0],
          y2 = _this$mousePoints$2[1];

      var pickingInfos = this.nebula.deckgl.pickObjects({
        x: Math.min(x1, x2),
        y: Math.min(y1, y2),
        width: Math.abs(x2 - x1),
        height: Math.abs(y2 - y1),
        layerIds: this._getLayerIds()
      });

      this._selectFromPickingInfos(pickingInfos);
    }
  }, {
    key: "_selectPolygonObjects",
    value: function _selectPolygonObjects() {
      var pickingInfos = this.nebula.deckgl.pickObjects(_objectSpread({}, this._getBoundingBox(), {
        layerIds: [LAYER_ID_PICK].concat(_toConsumableArray(this._getLayerIds()))
      }));

      this._selectFromPickingInfos(pickingInfos.filter(function (item) {
        return item.layer.id !== LAYER_ID_PICK;
      }));
    }
  }, {
    key: "_getMousePosFromEvent",
    value: function _getMousePosFromEvent(event) {
      var offsetX = event.offsetX,
          offsetY = event.offsetY;
      return [offsetX, offsetY];
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event, lngLat, selectionType) {
      // capture all events (mouse-up is needed to prevent us stuck in moving map)
      if (event.type !== 'mouseup') event.stopPropagation();
      this.usePolygon = selectionType === SELECTION_TYPE.POLYGON;
      var redraw = false;
      var deactivate = false;
      var usePolygon = this.usePolygon,
          landPoints = this.landPoints,
          mousePoints = this.mousePoints;

      if (event.type === 'mousedown') {
        if (usePolygon && landPoints.length) {
          // if landPoints.length is zero we want to insert two points (so we let it run the else)
          // also don't insert if polygon is invalid
          if (this.landPoints.length < 3 || this.validPolygon) {
            landPoints.push(lngLat);
            mousePoints.push(this._getMousePosFromEvent(event));
          }
        } else {
          this.landPoints = [lngLat, lngLat];

          var m = this._getMousePosFromEvent(event);

          this.mousePoints = [m, m];
        }

        redraw = true;
      } else if (event.type === 'mousemove' && landPoints.length) {
        // update last point
        landPoints[landPoints.length - 1] = lngLat;
        mousePoints[mousePoints.length - 1] = this._getMousePosFromEvent(event);
        redraw = true;
      } else if (event.type === 'mouseup') {
        if (usePolygon) {
          // check to see if completed
          // TODO: Maybe double-click to finish?
          if (landPoints.length > 4 && (0, _distance.default)(landPoints[0], landPoints[landPoints.length - 1]) < POLYGON_THRESHOLD && this.validPolygon) {
            this._selectPolygonObjects();

            this.reset();
            redraw = true;
            deactivate = true;
          }
        } else {
          this._selectRectangleObjects();

          this.reset();
          redraw = true;
          deactivate = true;
        }
      }

      return {
        redraw: redraw,
        deactivate: deactivate
      };
    }
  }, {
    key: "reset",
    value: function reset() {
      this.landPoints = [];
      this.mousePoints = [];
    }
  }, {
    key: "_makeStartPointHighlight",
    value: function _makeStartPointHighlight(center) {
      var buffer = (0, _buffer.default)((0, _helpers.point)(center), POLYGON_THRESHOLD / 4.0);
      return (0, _bboxPolygon.default)((0, _bbox.default)(buffer)).geometry.coordinates;
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;

      var data = [];
      var dataPick = [];

      if (!this.usePolygon && this.landPoints.length === 2) {
        // Use mouse points instead of land points so we get the right shape
        var _this$mousePoints = _slicedToArray(this.mousePoints, 2),
            _this$mousePoints$3 = _slicedToArray(_this$mousePoints[0], 2),
            x1 = _this$mousePoints$3[0],
            y1 = _this$mousePoints$3[1],
            _this$mousePoints$4 = _slicedToArray(_this$mousePoints[1], 2),
            x2 = _this$mousePoints$4[0],
            y2 = _this$mousePoints$4[1];

        var selPolygon = [[x1, y1], [x1, y2], [x2, y2], [x2, y1], [x1, y1]].map(function (mousePos) {
          return _this.nebula.unprojectMousePosition(mousePos);
        });
        data.push({
          polygon: selPolygon,
          lineColor: POLYGON_LINE_COLOR,
          fillColor: POLYGON_FILL_COLOR
        });
      } else if (this.usePolygon && this.landPoints.length) {
        data.push({
          polygon: this.landPoints,
          lineColor: POLYGON_LINE_COLOR,
          fillColor: POLYGON_FILL_COLOR
        }); // Hack: use a polygon to hide the outside, because pickObjects()
        // does not support polygons

        if (this.landPoints.length >= 3) {
          var landPointsPoly = (0, _helpers.polygon)([_toConsumableArray(this.landPoints).concat([this.landPoints[0]])]);
          var bigBuffer = (0, _buffer.default)((0, _helpers.point)(this.landPoints[0]), EXPANSION_KM);
          var bigPolygon;

          try {
            // turfDifference throws an exception if the polygon
            // intersects with itself
            bigPolygon = (0, _difference.default)(bigBuffer, landPointsPoly);
            dataPick.push({
              polygon: bigPolygon.geometry.coordinates,
              fillColor: [0, 0, 0, 1]
            });
            this.validPolygon = true;
          } catch (e) {
            // invalid selection polygon
            this.validPolygon = false;
          }
        }
      }

      if (this.landPoints.length) {
        // highlight start point
        data.push({
          polygon: this._makeStartPointHighlight(this.landPoints[0]),
          lineColor: [0, 0, 0, 0],
          fillColor: POLYGON_LINE_COLOR
        });
      } // Hack to make the PolygonLayer() stay active,
      // otherwise it takes 3 seconds (!) to init!
      // TODO: fix this


      data.push({
        polygon: [[0, 0]]
      });
      dataPick.push({
        polygon: [[0, 0]]
      });
      return [new _layers.PolygonLayer({
        id: LAYER_ID_VIEW,
        data: data,
        fp64: false,
        opacity: 1.0,
        pickable: false,
        lineWidthMinPixels: POLYGON_LINE_WIDTH,
        lineWidthMaxPixels: POLYGON_LINE_WIDTH,
        lineDashJustified: true,
        getLineDashArray: function getLineDashArray(x) {
          return POLYGON_DASHES;
        },
        getLineColor: function getLineColor(obj) {
          return obj.lineColor || [0, 0, 0, 255];
        },
        getFillColor: function getFillColor(obj) {
          return obj.fillColor || [0, 0, 0, 255];
        },
        getPolygon: function getPolygon(o) {
          return o.polygon;
        }
      }), new _layers.PolygonLayer({
        id: LAYER_ID_PICK,
        data: dataPick,
        getLineColor: function getLineColor(obj) {
          return obj.lineColor || [0, 0, 0, 255];
        },
        getFillColor: function getFillColor(obj) {
          return obj.fillColor || [0, 0, 0, 255];
        },
        fp64: false,
        opacity: 1.0,
        stroked: false,
        pickable: true,
        getPolygon: function getPolygon(o) {
          return o.polygon;
        }
      })];
    }
  }]);

  return DeckDrawer;
}();

exports.default = DeckDrawer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvZGVjay1yZW5kZXJlci9kZWNrLWRyYXdlci5qcyJdLCJuYW1lcyI6WyJQT0xZR09OX0xJTkVfQ09MT1IiLCJQT0xZR09OX0ZJTExfQ09MT1IiLCJQT0xZR09OX0xJTkVfV0lEVEgiLCJQT0xZR09OX0RBU0hFUyIsIlBPTFlHT05fVEhSRVNIT0xEIiwiRVhQQU5TSU9OX0tNIiwiTEFZRVJfSURfVklFVyIsIkxBWUVSX0lEX1BJQ0siLCJTRUxFQ1RJT05fVFlQRSIsIk5PTkUiLCJSRUNUQU5HTEUiLCJQT0xZR09OIiwiRGVja0RyYXdlciIsIm5lYnVsYSIsInVzZVBvbHlnb24iLCJsYW5kUG9pbnRzIiwibW91c2VQb2ludHMiLCJkZWNrZ2wiLCJwcm9wcyIsImxheWVycyIsImZpbHRlciIsImwiLCJuZWJ1bGFMYXllciIsImVuYWJsZVNlbGVjdGlvbiIsIm1hcCIsImlkIiwicGlja2luZ0luZm9zIiwib2JqZWN0cyIsImxheWVyIiwiaW5kZXgiLCJvYmplY3QiLCJvcmlnaW5hbCIsImRlY2tDYWNoZSIsIm9yaWdpbmFscyIsIm9uU2VsZWN0aW9uIiwiYWxsWCIsIm1vdXNlUG9pbnQiLCJhbGxZIiwieCIsIk1hdGgiLCJtaW4iLCJ5IiwibWF4WCIsIm1heCIsIm1heFkiLCJ3aWR0aCIsImhlaWdodCIsImxlbmd0aCIsIngxIiwieTEiLCJ4MiIsInkyIiwicGlja09iamVjdHMiLCJhYnMiLCJsYXllcklkcyIsIl9nZXRMYXllcklkcyIsIl9zZWxlY3RGcm9tUGlja2luZ0luZm9zIiwiX2dldEJvdW5kaW5nQm94IiwiaXRlbSIsImV2ZW50Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJsbmdMYXQiLCJzZWxlY3Rpb25UeXBlIiwidHlwZSIsInN0b3BQcm9wYWdhdGlvbiIsInJlZHJhdyIsImRlYWN0aXZhdGUiLCJ2YWxpZFBvbHlnb24iLCJwdXNoIiwiX2dldE1vdXNlUG9zRnJvbUV2ZW50IiwibSIsIl9zZWxlY3RQb2x5Z29uT2JqZWN0cyIsInJlc2V0IiwiX3NlbGVjdFJlY3RhbmdsZU9iamVjdHMiLCJjZW50ZXIiLCJidWZmZXIiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwiZGF0YSIsImRhdGFQaWNrIiwic2VsUG9seWdvbiIsIm1vdXNlUG9zIiwidW5wcm9qZWN0TW91c2VQb3NpdGlvbiIsInBvbHlnb24iLCJsaW5lQ29sb3IiLCJmaWxsQ29sb3IiLCJsYW5kUG9pbnRzUG9seSIsImJpZ0J1ZmZlciIsImJpZ1BvbHlnb24iLCJlIiwiX21ha2VTdGFydFBvaW50SGlnaGxpZ2h0IiwiUG9seWdvbkxheWVyIiwiZnA2NCIsIm9wYWNpdHkiLCJwaWNrYWJsZSIsImxpbmVXaWR0aE1pblBpeGVscyIsImxpbmVXaWR0aE1heFBpeGVscyIsImxpbmVEYXNoSnVzdGlmaWVkIiwiZ2V0TGluZURhc2hBcnJheSIsImdldExpbmVDb2xvciIsIm9iaiIsImdldEZpbGxDb2xvciIsImdldFBvbHlnb24iLCJvIiwic3Ryb2tlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxrQkFBa0IsR0FBRyxDQUFDLENBQUQsRUFBSSxHQUFKLEVBQVMsQ0FBVCxFQUFZLEdBQVosQ0FBM0I7QUFDQSxJQUFNQyxrQkFBa0IsR0FBRyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixFQUFoQixDQUEzQjtBQUNBLElBQU1DLGtCQUFrQixHQUFHLENBQTNCO0FBQ0EsSUFBTUMsY0FBYyxHQUFHLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBdkI7QUFDQSxJQUFNQyxpQkFBaUIsR0FBRyxJQUExQjtBQUNBLElBQU1DLFlBQVksR0FBRyxFQUFyQjtBQUNBLElBQU1DLGFBQWEsR0FBRyxnQkFBdEI7QUFDQSxJQUFNQyxhQUFhLEdBQUcsZ0JBQXRCO0FBRU8sSUFBTUMsY0FBYyxHQUFHO0FBQzVCQyxFQUFBQSxJQUFJLEVB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QUosQ0FBaUI7QUFDZm5FLFFBQUFBLEVBQUUsRUFBRWxCLGFBRFc7QUFFZndFLFFBQUFBLElBQUksRUFBRUMsUUFGUztBQUdmb0IsUUFBQUEsWUFBWSxFQUFFLHNCQUFBQyxHQUFHO0FBQUEsaUJBQUlBLEdBQUcsQ0FBQ2hCLFNBQUosSUFBaUIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxHQUFWLENBQXJCO0FBQUEsU0FIRjtBQUlmaUIsUUFBQUEsWUFBWSxFQUFFLHNCQUFBRCxHQUFHO0FBQUEsaUJBQUlBLEdBQUcsQ0FBQ2YsU0FBSixJQUFpQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLEdBQVYsQ0FBckI7QUFBQSxTQUpGO0FBS2ZPLFFBQUFBLElBQUksRUFBRSxLQUxTO0FBTWZDLFFBQUFBLE9BQU8sRUFBRSxHQU5NO0FBT2ZXLFFBQUFBLE9BQU8sRUFBRSxLQVBNO0FBUWZWLFFBQUFBLFFBQVEsRUFBRSxJQVJLO0FBU2ZRLFFBQUFBLFVBQVUsRUFBRSxvQkFBQUMsQ0FBQztBQUFBLGlCQUFJQSxDQUFDLENBQUNwQixPQUFOO0FBQUE7QUFURSxPQUFqQixDQWZLLENBQVA7QUEyQkQiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuaW1wb3J0IHsgUG9seWdvbkxheWVyIH0gZnJvbSAnQGRlY2suZ2wvbGF5ZXJzJztcbmltcG9ydCB7IHBvaW50LCBwb2x5Z29uIH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5pbXBvcnQgdHVyZkJib3ggZnJvbSAnQHR1cmYvYmJveCc7XG5pbXBvcnQgdHVyZkJib3hQb2x5Z29uIGZyb20gJ0B0dXJmL2Jib3gtcG9seWdvbic7XG5pbXBvcnQgdHVyZkJ1ZmZlciBmcm9tICdAdHVyZi9idWZmZXInO1xuaW1wb3J0IHR1cmZEaWZmZXJlbmNlIGZyb20gJ0B0dXJmL2RpZmZlcmVuY2UnO1xuaW1wb3J0IHR1cmZEaXN0YW5jZSBmcm9tICdAdHVyZi9kaXN0YW5jZSc7XG5cbmNvbnN0IFBPTFlHT05fTElORV9DT0xPUiA9IFswLCAyNTUsIDAsIDI1NV07XG5jb25zdCBQT0xZR09OX0ZJTExfQ09MT1IgPSBbMjU1LCAyNTUsIDI1NSwgOTBdO1xuY29uc3QgUE9MWUdPTl9MSU5FX1dJRFRIID0gMjtcbmNvbnN0IFBPTFlHT05fREFTSEVTID0gWzIwLCAyMF07XG5jb25zdCBQT0xZR09OX1RIUkVTSE9MRCA9IDAuMDE7XG5jb25zdCBFWFBBTlNJT05fS00gPSAxMDtcbmNvbnN0IExBWUVSX0lEX1ZJRVcgPSAnRGVja0RyYXdlclZpZXcnO1xuY29uc3QgTEFZRVJfSURfUElDSyA9ICdEZWNrRHJhd2VyUGljayc7XG5cbmV4cG9ydCBjb25zdCBTRUxFQ1RJT05fVFlQRSA9IHtcbiAgTk9ORTogbnVsbCxcbiAgUkVDVEFOR0xFOiAncmVjdGFuZ2xlJyxcbiAgUE9MWUdPTjogJ3BvbHlnb24nXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWNrRHJhd2VyIHtcbiAgbmVidWxhOiBPYmplY3Q7XG4gIHVzZVBvbHlnb246IGJvb2xlYW47XG4gIHZhbGlkUG9seWdvbjogYm9vbGVhbjtcbiAgbGFuZFBvaW50czogW251bWJlciwgbnVtYmVyXVtdO1xuICBtb3VzZVBvaW50czogW251bWJlciwgbnVtYmVyXVtdO1xuXG4gIGNvbnN0cnVjdG9yKG5lYnVsYTogT2JqZWN0KSB7XG4gICAgdGhpcy5uZWJ1bGEgPSBuZWJ1bGE7XG4gICAgdGhpcy51c2VQb2x5Z29uID0gZmFsc2U7XG4gICAgdGhpcy5sYW5kUG9pbnRzID0gW107XG4gICAgdGhpcy5tb3VzZVBvaW50cyA9IFtdO1xuICB9XG5cbiAgX2dldExheWVySWRzKCkge1xuICAgIC8vIFRPRE86IHNvcnQgYnkgbW91c2UgcHJpb3JpdHlcbiAgICByZXR1cm4gdGhpcy5uZWJ1bGEuZGVja2dsLnByb3BzLmxheWVyc1xuICAgICAgLmZpbHRlcihsID0+IGwgJiYgbC5wcm9wcyAmJiBsLnByb3BzLm5lYnVsYUxheWVyICYmIGwucHJvcHMubmVidWxhTGF5ZXIuZW5hYmxlU2VsZWN0aW9uKVxuICAgICAgLm1hcChsID0+IGwuaWQpO1xuICB9XG5cbiAgX3NlbGVjdEZyb21QaWNraW5nSW5mb3MocGlja2luZ0luZm9zOiBPYmplY3RbXSkge1xuICAgIGNvbnN0IG9iamVjdHMgPSBwaWNraW5nSW5mb3MubWFwKFxuICAgICAgKHsgbGF5ZXIsIGluZGV4LCBvYmplY3QgfSkgPT5cbiAgICAgICAgb2JqZWN0Lm9yaWdpbmFsIHx8IGxheWVyLnByb3BzLm5lYnVsYUxheWVyLmRlY2tDYWNoZS5vcmlnaW5hbHNbaW5kZXhdXG4gICAgKTtcbiAgICB0aGlzLm5lYnVsYS5wcm9wcy5vblNlbGVjdGlvbihvYmplY3RzKTtcbiAgfVxuXG4gIF9nZXRCb3VuZGluZ0JveCgpOiBPYmplY3Qge1xuICAgIGNvbnN0IHsgbW91c2VQb2ludHMgfSA9IHRoaXM7XG4gICAgY29uc3QgYWxsWCA9IG1vdXNlUG9pbnRzLm1hcChtb3VzZVBvaW50ID0+IG1vdXNlUG9pbnRbMF0pO1xuICAgIGNvbnN0IGFsbFkgPSBtb3VzZVBvaW50cy5tYXAobW91c2VQb2ludCA9PiBtb3VzZVBvaW50WzFdKTtcbiAgICBjb25zdCB4ID0gTWF0aC5taW4oLi4uYWxsWCk7XG4gICAgY29uc3QgeSA9IE1hdGgubWluKC4uLmFsbFkpO1xuICAgIGNvbnN0IG1heFggPSBNYXRoLm1heCguLi5hbGxYKTtcbiAgICBjb25zdCBtYXhZID0gTWF0aC5tYXgoLi4uYWxsWSk7XG5cbiAgICByZXR1cm4geyB4LCB5LCB3aWR0aDogbWF4WCAtIHgsIGhlaWdodDogbWF4WSAtIHkgfTtcbiAgfVxuXG4gIF9zZWxlY3RSZWN0YW5nbGVPYmplY3RzKCkge1xuICAgIGlmICh0aGlzLmxhbmRQb2ludHMubGVuZ3RoICE9PSAyKSByZXR1cm47XG5cbiAgICBjb25zdCBbeDEsIHkxXSA9IHRoaXMubW91c2VQb2ludHNbMF07XG4gICAgY29uc3QgW3gyLCB5Ml0gPSB0aGlzLm1vdXNlUG9pbnRzWzFdO1xuICAgIGNvbnN0IHBpY2tpbmdJbmZvcyA9IHRoaXMubmVidWxhLmRlY2tnbC5waWNrT2JqZWN0cyh7XG4gICAgICB4OiBNYXRoLm1pbih4MSwgeDIpLFxuICAgICAgeTogTWF0aC5taW4oeTEsIHkyKSxcbiAgICAgIHdpZHRoOiBNYXRoLmFicyh4MiAtIHgxKSxcbiAgICAgIGhlaWdodDogTWF0aC5hYnMoeTIgLSB5MSksXG4gICAgICBsYXllcklkczogdGhpcy5fZ2V0TGF5ZXJJZHMoKVxuICAgIH0pO1xuXG4gICAgdGhpcy5fc2VsZWN0RnJvbVBpY2tpbmdJbmZvcyhwaWNraW5nSW5mb3MpO1xuICB9XG5cbiAgX3NlbGVjdFBvbHlnb25PYmplY3RzKCkge1xuICAgIGNvbnN0IHBpY2tpbmdJbmZvcyA9IHRoaXMubmVidWxhLmRlY2tnbC5waWNrT2JqZWN0cyh7XG4gICAgICAuLi50aGlzLl9nZXRCb3VuZGluZ0JveCgpLFxuICAgICAgbGF5ZXJJZHM6IFtMQVlFUl9JRF9QSUNLLCAuLi50aGlzLl9nZXRMYXllcklkcygpXVxuICAgIH0pO1xuXG4gICAgdGhpcy5fc2VsZWN0RnJvbVBpY2tpbmdJbmZvcyhwaWNraW5nSW5mb3MuZmlsdGVyKGl0ZW0gPT4gaXRlbS5sYXllci5pZCAhPT0gTEFZRVJfSURfUElDSykpO1xuICB9XG5cbiAgX2dldE1vdXNlUG9zRnJvbUV2ZW50KGV2ZW50OiBPYmplY3QpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgIHJldHVybiBbb2Zmc2V0WCwgb2Zmc2V0WV07XG4gIH1cblxuICBoYW5kbGVFdmVudChcbiAgICBldmVudDogT2JqZWN0LFxuICAgIGxuZ0xhdDogW251bWJlciwgbnVtYmVyXSxcbiAgICBzZWxlY3Rpb25UeXBlOiBudW1iZXJcbiAgKTogeyByZWRyYXc6IGJvb2xlYW4sIGRlYWN0aXZhdGU6IGJvb2xlYW4gfSB7XG4gICAgLy8gY2FwdHVyZSBhbGwgZXZlbnRzIChtb3VzZS11cCBpcyBuZWVkZWQgdG8gcHJldmVudCB1cyBzdHVjayBpbiBtb3ZpbmcgbWFwKVxuICAgIGlmIChldmVudC50eXBlICE9PSAnbW91c2V1cCcpIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgdGhpcy51c2VQb2x5Z29uID0gc2VsZWN0aW9uVHlwZSA9PT0gU0VMRUNUSU9OX1RZUEUuUE9MWUdPTjtcblxuICAgIGxldCByZWRyYXcgPSBmYWxzZTtcbiAgICBsZXQgZGVhY3RpdmF0ZSA9IGZhbHNlO1xuXG4gICAgY29uc3QgeyB1c2VQb2x5Z29uLCBsYW5kUG9pbnRzLCBtb3VzZVBvaW50cyB9ID0gdGhpcztcblxuICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgaWYgKHVzZVBvbHlnb24gJiYgbGFuZFBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gaWYgbGFuZFBvaW50cy5sZW5ndGggaXMgemVybyB3ZSB3YW50IHRvIGluc2VydCB0d28gcG9pbnRzIChzbyB3ZSBsZXQgaXQgcnVuIHRoZSBlbHNlKVxuICAgICAgICAvLyBhbHNvIGRvbid0IGluc2VydCBpZiBwb2x5Z29uIGlzIGludmFsaWRcbiAgICAgICAgaWYgKHRoaXMubGFuZFBvaW50cy5sZW5ndGggPCAzIHx8IHRoaXMudmFsaWRQb2x5Z29uKSB7XG4gICAgICAgICAgbGFuZFBvaW50cy5wdXNoKGxuZ0xhdCk7XG4gICAgICAgICAgbW91c2VQb2ludHMucHVzaCh0aGlzLl9nZXRNb3VzZVBvc0Zyb21FdmVudChldmVudCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhbmRQb2ludHMgPSBbbG5nTGF0LCBsbmdMYXRdO1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fZ2V0TW91c2VQb3NGcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICB0aGlzLm1vdXNlUG9pbnRzID0gW20sIG1dO1xuICAgICAgfVxuICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnICYmIGxhbmRQb2ludHMubGVuZ3RoKSB7XG4gICAgICAvLyB1cGRhdGUgbGFzdCBwb2ludFxuICAgICAgbGFuZFBvaW50c1tsYW5kUG9pbnRzLmxlbmd0aCAtIDFdID0gbG5nTGF0O1xuICAgICAgbW91c2VQb2ludHNbbW91c2VQb2ludHMubGVuZ3RoIC0gMV0gPSB0aGlzLl9nZXRNb3VzZVBvc0Zyb21FdmVudChldmVudCk7XG4gICAgICByZWRyYXcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNldXAnKSB7XG4gICAgICBpZiAodXNlUG9seWdvbikge1xuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgY29tcGxldGVkXG4gICAgICAgIC8vIFRPRE86IE1heWJlIGRvdWJsZS1jbGljayB0byBmaW5pc2g/XG4gICAgICAgIGlmIChcbiAgICAgICAgICBsYW5kUG9pbnRzLmxlbmd0aCA+IDQgJiZcbiAgICAgICAgICB0dXJmRGlzdGFuY2UobGFuZFBvaW50c1swXSwgbGFuZFBvaW50c1tsYW5kUG9pbnRzLmxlbmd0aCAtIDFdKSA8IFBPTFlHT05fVEhSRVNIT0xEICYmXG4gICAgICAgICAgdGhpcy52YWxpZFBvbHlnb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0UG9seWdvbk9iamVjdHMoKTtcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICBkZWFjdGl2YXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0UmVjdGFuZ2xlT2JqZWN0cygpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgIGRlYWN0aXZhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHJlZHJhdywgZGVhY3RpdmF0ZSB9O1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5sYW5kUG9pbnRzID0gW107XG4gICAgdGhpcy5tb3VzZVBvaW50cyA9IFtdO1xuICB9XG5cbiAgX21ha2VTdGFydFBvaW50SGlnaGxpZ2h0KGNlbnRlcjogW251bWJlciwgbnVtYmVyXSk6IG51bWJlcltdIHtcbiAgICBjb25zdCBidWZmZXIgPSB0dXJmQnVmZmVyKHBvaW50KGNlbnRlciksIFBPTFlHT05fVEhSRVNIT0xEIC8gNC4wKTtcbiAgICByZXR1cm4gdHVyZkJib3hQb2x5Z29uKHR1cmZCYm94KGJ1ZmZlcikpLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICBjb25zdCBkYXRhUGljayA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLnVzZVBvbHlnb24gJiYgdGhpcy5sYW5kUG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgLy8gVXNlIG1vdXNlIHBvaW50cyBpbnN0ZWFkIG9mIGxhbmQgcG9pbnRzIHNvIHdlIGdldCB0aGUgcmlnaHQgc2hhcGVcbiAgICAgIC8vIG5vIG1hdHRlciB3aGF0IGJlYXJpbmcgaXMuXG4gICAgICBjb25zdCBbW3gxLCB5MV0sIFt4MiwgeTJdXSA9IHRoaXMubW91c2VQb2ludHM7XG4gICAgICBjb25zdCBzZWxQb2x5Z29uID0gW1t4MSwgeTFdLCBbeDEsIHkyXSwgW3gyLCB5Ml0sIFt4MiwgeTFdLCBbeDEsIHkxXV0ubWFwKG1vdXNlUG9zID0+XG4gICAgICAgIHRoaXMubmVidWxhLnVucHJvamVjdE1vdXNlUG9zaXRpb24obW91c2VQb3MpXG4gICAgICApO1xuICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgcG9seWdvbjogc2VsUG9seWdvbixcbiAgICAgICAgbGluZUNvbG9yOiBQT0xZR09OX0xJTkVfQ09MT1IsXG4gICAgICAgIGZpbGxDb2xvcjogUE9MWUdPTl9GSUxMX0NPTE9SXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXNlUG9seWdvbiAmJiB0aGlzLmxhbmRQb2ludHMubGVuZ3RoKSB7XG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICBwb2x5Z29uOiB0aGlzLmxhbmRQb2ludHMsXG4gICAgICAgIGxpbmVDb2xvcjogUE9MWUdPTl9MSU5FX0NPTE9SLFxuICAgICAgICBmaWxsQ29sb3I6IFBPTFlHT05fRklMTF9DT0xPUlxuICAgICAgfSk7XG5cbiAgICAgIC8vIEhhY2s6IHVzZSBhIHBvbHlnb24gdG8gaGlkZSB0aGUgb3V0c2lkZSwgYmVjYXVzZSBwaWNrT2JqZWN0cygpXG4gICAgICAvLyBkb2VzIG5vdCBzdXBwb3J0IHBvbHlnb25zXG4gICAgICBpZiAodGhpcy5sYW5kUG9pbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIGNvbnN0IGxhbmRQb2ludHNQb2x5ID0gcG9seWdvbihbWy4uLnRoaXMubGFuZFBvaW50cywgdGhpcy5sYW5kUG9pbnRzWzBdXV0pO1xuICAgICAgICBjb25zdCBiaWdCdWZmZXIgPSB0dXJmQnVmZmVyKHBvaW50KHRoaXMubGFuZFBvaW50c1swXSksIEVYUEFOU0lPTl9LTSk7XG4gICAgICAgIGxldCBiaWdQb2x5Z29uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIHR1cmZEaWZmZXJlbmNlIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHBvbHlnb25cbiAgICAgICAgICAvLyBpbnRlcnNlY3RzIHdpdGggaXRzZWxmXG4gICAgICAgICAgYmlnUG9seWdvbiA9IHR1cmZEaWZmZXJlbmNlKGJpZ0J1ZmZlciwgbGFuZFBvaW50c1BvbHkpO1xuICAgICAgICAgIGRhdGFQaWNrLnB1c2goe1xuICAgICAgICAgICAgcG9seWdvbjogYmlnUG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlcyxcbiAgICAgICAgICAgIGZpbGxDb2xvcjogWzAsIDAsIDAsIDFdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy52YWxpZFBvbHlnb24gPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaW52YWxpZCBzZWxlY3Rpb24gcG9seWdvblxuICAgICAgICAgIHRoaXMudmFsaWRQb2x5Z29uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5sYW5kUG9pbnRzLmxlbmd0aCkge1xuICAgICAgLy8gaGlnaGxpZ2h0IHN0YXJ0IHBvaW50XG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICBwb2x5Z29uOiB0aGlzLl9tYWtlU3RhcnRQb2ludEhpZ2hsaWdodCh0aGlzLmxhbmRQb2ludHNbMF0pLFxuICAgICAgICBsaW5lQ29sb3I6IFswLCAwLCAwLCAwXSxcbiAgICAgICAgZmlsbENvbG9yOiBQT0xZR09OX0xJTkVfQ09MT1JcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEhhY2sgdG8gbWFrZSB0aGUgUG9seWdvbkxheWVyKCkgc3RheSBhY3RpdmUsXG4gICAgLy8gb3RoZXJ3aXNlIGl0IHRha2VzIDMgc2Vjb25kcyAoISkgdG8gaW5pdCFcbiAgICAvLyBUT0RPOiBmaXggdGhpc1xuICAgIGRhdGEucHVzaCh7IHBvbHlnb246IFtbMCwgMF1dIH0pO1xuICAgIGRhdGFQaWNrLnB1c2goeyBwb2x5Z29uOiBbWzAsIDBdXSB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICBuZXcgUG9seWdvbkxheWVyKHtcbiAgICAgICAgaWQ6IExBWUVSX0lEX1ZJRVcsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGZwNjQ6IGZhbHNlLFxuICAgICAgICBvcGFjaXR5OiAxLjAsXG4gICAgICAgIHBpY2thYmxlOiBmYWxzZSxcbiAgICAgICAgbGluZVdpZHRoTWluUGl4ZWxzOiBQT0xZR09OX0xJTkVfV0lEVEgsXG4gICAgICAgIGxpbmVXaWR0aE1heFBpeGVsczogUE9MWUdPTl9MSU5FX1dJRFRILFxuICAgICAgICBsaW5lRGFzaEp1c3RpZmllZDogdHJ1ZSxcbiAgICAgICAgZ2V0TGluZURhc2hBcnJheTogeCA9PiBQT0xZR09OX0RBU0hFUyxcbiAgICAgICAgZ2V0TGluZUNvbG9yOiBvYmogPT4gb2JqLmxpbmVDb2xvciB8fCBbMCwgMCwgMCwgMjU1XSxcbiAgICAgICAgZ2V0RmlsbENvbG9yOiBvYmogPT4gb2JqLmZpbGxDb2xvciB8fCBbMCwgMCwgMCwgMjU1XSxcbiAgICAgICAgZ2V0UG9seWdvbjogbyA9PiBvLnBvbHlnb25cbiAgICAgIH0pLFxuICAgICAgbmV3IFBvbHlnb25MYXllcih7XG4gICAgICAgIGlkOiBMQVlFUl9JRF9QSUNLLFxuICAgICAgICBkYXRhOiBkYXRhUGljayxcbiAgICAgICAgZ2V0TGluZUNvbG9yOiBvYmogPT4gb2JqLmxpbmVDb2xvciB8fCBbMCwgMCwgMCwgMjU1XSxcbiAgICAgICAgZ2V0RmlsbENvbG9yOiBvYmogPT4gb2JqLmZpbGxDb2xvciB8fCBbMCwgMCwgMCwgMjU1XSxcbiAgICAgICAgZnA2NDogZmFsc2UsXG4gICAgICAgIG9wYWNpdHk6IDEuMCxcbiAgICAgICAgc3Ryb2tlZDogZmFsc2UsXG4gICAgICAgIHBpY2thYmxlOiB0cnVlLFxuICAgICAgICBnZXRQb2x5Z29uOiBvID0+IG8ucG9seWdvblxuICAgICAgfSlcbiAgICBdO1xuICB9XG59XG4iXX0=